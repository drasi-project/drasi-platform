// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do one of these:
//
//    using Drasi.Reaction.SDK.Models.QueryOutput;
//
//    var bootstrapCompletedSignal = BootstrapCompletedSignal.FromJson(jsonString);
//    var bootstrapStartedSignal = BootstrapStartedSignal.FromJson(jsonString);
//    var changeEvent = ChangeEvent.FromJson(jsonString);
//    var controlEvent = ControlEvent.FromJson(jsonString);
//    var controlSignal = ControlSignal.FromJson(jsonString);
//    var deletedSignal = DeletedSignal.FromJson(jsonString);
//    var resultEvent = ResultEvent.FromJson(jsonString);
//    var runningSignal = RunningSignal.FromJson(jsonString);
//    var stoppedSignal = StoppedSignal.FromJson(jsonString);
//    var updatePayload = UpdatePayload.FromJson(jsonString);
//    var versions = Versions.FromJson(jsonString);
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace Drasi.Reaction.SDK.Models.QueryOutput
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    /// <summary>
    /// A signal that indicates that the query has completed bootstrapping
    /// </summary>
    public partial class BootstrapCompletedSignal
    {
        [JsonPropertyName("kind")]
        public BootstrapCompletedSignalKind Kind { get; set; }
    }

    /// <summary>
    /// A signal that indicates that the query is starting to bootstrap
    /// </summary>
    public partial class BootstrapStartedSignal
    {
        [JsonPropertyName("kind")]
        public BootstrapStartedSignalKind Kind { get; set; }
    }

    /// <summary>
    /// An event that represents a changes in the result set
    /// </summary>
    public partial class ChangeEvent
    {
        /// <summary>
        /// The results that were added to the result set as a consequence of the change
        /// </summary>
        [JsonPropertyName("addedResults")]
        public Dictionary<string, object>[] AddedResults { get; set; }

        /// <summary>
        /// The results that were deleted from the result set as a consequence of the change
        /// </summary>
        [JsonPropertyName("deletedResults")]
        public Dictionary<string, object>[] DeletedResults { get; set; }

        [JsonPropertyName("kind")]
        public ChangeEventKind Kind { get; set; }

        /// <summary>
        /// The results that were updated on the result set as a consequence of the change
        /// </summary>
        [JsonPropertyName("updatedResults")]
        public UpdatedResultElement[] UpdatedResults { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("metadata")]
        public Dictionary<string, object> Metadata { get; set; }

        /// <summary>
        /// The ID of the query that the event originated from
        /// </summary>
        [JsonPropertyName("queryId")]
        public string QueryId { get; set; }

        /// <summary>
        /// The sequence number of the event
        /// </summary>
        [JsonPropertyName("sequence")]
        public long Sequence { get; set; }

        /// <summary>
        /// The time at which the source change was recorded
        /// </summary>
        [JsonPropertyName("sourceTimeMs")]
        public long SourceTimeMs { get; set; }
    }

    /// <summary>
    /// A payload that represents the before and after snapshots of a result
    /// </summary>
    public partial class UpdatedResultElement
    {
        /// <summary>
        /// The snapshot of the result after the change
        /// </summary>
        [JsonPropertyName("after")]
        public Dictionary<string, object> After { get; set; }

        /// <summary>
        /// The snapshot of the result before the change
        /// </summary>
        [JsonPropertyName("before")]
        public Dictionary<string, object> Before { get; set; }

        /// <summary>
        /// The keys used to group or categorize this update, if applicable
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("groupingKeys")]
        public string[] GroupingKeys { get; set; }
    }

    /// <summary>
    /// An event that represents a control signal from the query, such are start, stop, etc.
    /// </summary>
    public partial class ControlEvent
    {
        [JsonPropertyName("controlSignal")]
        public ControlSignalClass ControlSignal { get; set; }

        [JsonPropertyName("kind")]
        public ControlEventKind Kind { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("metadata")]
        public Dictionary<string, object> Metadata { get; set; }

        /// <summary>
        /// The ID of the query that the event originated from
        /// </summary>
        [JsonPropertyName("queryId")]
        public string QueryId { get; set; }

        /// <summary>
        /// The sequence number of the event
        /// </summary>
        [JsonPropertyName("sequence")]
        public long Sequence { get; set; }

        /// <summary>
        /// The time at which the source change was recorded
        /// </summary>
        [JsonPropertyName("sourceTimeMs")]
        public long SourceTimeMs { get; set; }
    }

    public partial class ControlSignalClass
    {
        [JsonPropertyName("kind")]
        public ControlSignalKind Kind { get; set; }
    }

    public partial class ControlSignal
    {
        [JsonPropertyName("kind")]
        public ControlSignalKind Kind { get; set; }
    }

    /// <summary>
    /// A signal that indicates that the query has been deleted
    /// </summary>
    public partial class DeletedSignal
    {
        [JsonPropertyName("kind")]
        public DeletedSignalKind Kind { get; set; }
    }

    public partial class ResultEvent
    {
        [JsonPropertyName("kind")]
        public ResultEventKind Kind { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("metadata")]
        public Dictionary<string, object> Metadata { get; set; }

        /// <summary>
        /// The ID of the query that the event originated from
        /// </summary>
        [JsonPropertyName("queryId")]
        public string QueryId { get; set; }

        /// <summary>
        /// The sequence number of the event
        /// </summary>
        [JsonPropertyName("sequence")]
        public long Sequence { get; set; }

        /// <summary>
        /// The time at which the source change was recorded
        /// </summary>
        [JsonPropertyName("sourceTimeMs")]
        public long SourceTimeMs { get; set; }
    }

    /// <summary>
    /// A signal that indicates that the query has entered the running state
    /// </summary>
    public partial class RunningSignal
    {
        [JsonPropertyName("kind")]
        public RunningSignalKind Kind { get; set; }
    }

    /// <summary>
    /// A signal that indicates that the query has stopped
    /// </summary>
    public partial class StoppedSignal
    {
        [JsonPropertyName("kind")]
        public StoppedSignalKind Kind { get; set; }
    }

    /// <summary>
    /// A payload that represents the before and after snapshots of a result
    /// </summary>
    public partial class UpdatePayload
    {
        /// <summary>
        /// The snapshot of the result after the change
        /// </summary>
        [JsonPropertyName("after")]
        public Dictionary<string, object> After { get; set; }

        /// <summary>
        /// The snapshot of the result before the change
        /// </summary>
        [JsonPropertyName("before")]
        public Dictionary<string, object> Before { get; set; }

        /// <summary>
        /// The keys used to group or categorize this update, if applicable
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("groupingKeys")]
        public string[] GroupingKeys { get; set; }
    }

    public enum BootstrapCompletedSignalKind { BootstrapCompleted };

    public enum BootstrapStartedSignalKind { BootstrapStarted };

    public enum ChangeEventKind { Change };

    public enum ControlSignalKind { BootstrapCompleted, BootstrapStarted, Deleted, Running, Stopped };

    public enum ControlEventKind { Control };

    public enum DeletedSignalKind { Deleted };

    public enum ResultEventKind { Change, Control };

    public enum RunningSignalKind { Running };

    public enum StoppedSignalKind { Stopped };

    public enum VersionsEnum { V1 };

    public partial class BootstrapCompletedSignal
    {
        public static BootstrapCompletedSignal FromJson(string json) => JsonSerializer.Deserialize<BootstrapCompletedSignal>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class BootstrapStartedSignal
    {
        public static BootstrapStartedSignal FromJson(string json) => JsonSerializer.Deserialize<BootstrapStartedSignal>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class ChangeEvent
    {
        public static ChangeEvent FromJson(string json) => JsonSerializer.Deserialize<ChangeEvent>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class ControlEvent
    {
        public static ControlEvent FromJson(string json) => JsonSerializer.Deserialize<ControlEvent>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class ControlSignal
    {
        public static ControlSignal FromJson(string json) => JsonSerializer.Deserialize<ControlSignal>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class DeletedSignal
    {
        public static DeletedSignal FromJson(string json) => JsonSerializer.Deserialize<DeletedSignal>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class ResultEvent
    {
        public static ResultEvent FromJson(string json) => JsonSerializer.Deserialize<ResultEvent>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class RunningSignal
    {
        public static RunningSignal FromJson(string json) => JsonSerializer.Deserialize<RunningSignal>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class StoppedSignal
    {
        public static StoppedSignal FromJson(string json) => JsonSerializer.Deserialize<StoppedSignal>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public partial class UpdatePayload
    {
        public static UpdatePayload FromJson(string json) => JsonSerializer.Deserialize<UpdatePayload>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public class Versions
    {
        public static VersionsEnum FromJson(string json) => JsonSerializer.Deserialize<VersionsEnum>(json, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this BootstrapCompletedSignal self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this BootstrapStartedSignal self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this ChangeEvent self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this ControlEvent self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this ControlSignal self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this DeletedSignal self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this ResultEvent self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this RunningSignal self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this StoppedSignal self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this UpdatePayload self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
        public static string ToJson(this VersionsEnum self) => JsonSerializer.Serialize(self, Drasi.Reaction.SDK.Models.QueryOutput.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                BootstrapCompletedSignalKindConverter.Singleton,
                BootstrapStartedSignalKindConverter.Singleton,
                ChangeEventKindConverter.Singleton,
                ControlSignalKindConverter.Singleton,
                ControlEventKindConverter.Singleton,
                DeletedSignalKindConverter.Singleton,
                ResultEventKindConverter.Singleton,
                RunningSignalKindConverter.Singleton,
                StoppedSignalKindConverter.Singleton,
                VersionsEnumConverter.Singleton,
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
        };
    }

    internal class BootstrapCompletedSignalKindConverter : JsonConverter<BootstrapCompletedSignalKind>
    {
        public override bool CanConvert(Type t) => t == typeof(BootstrapCompletedSignalKind);

        public override BootstrapCompletedSignalKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "bootstrapCompleted")
            {
                return BootstrapCompletedSignalKind.BootstrapCompleted;
            }
            throw new Exception("Cannot unmarshal type BootstrapCompletedSignalKind");
        }

        public override void Write(Utf8JsonWriter writer, BootstrapCompletedSignalKind value, JsonSerializerOptions options)
        {
            if (value == BootstrapCompletedSignalKind.BootstrapCompleted)
            {
                JsonSerializer.Serialize(writer, "bootstrapCompleted", options);
                return;
            }
            throw new Exception("Cannot marshal type BootstrapCompletedSignalKind");
        }

        public static readonly BootstrapCompletedSignalKindConverter Singleton = new BootstrapCompletedSignalKindConverter();
    }

    internal class BootstrapStartedSignalKindConverter : JsonConverter<BootstrapStartedSignalKind>
    {
        public override bool CanConvert(Type t) => t == typeof(BootstrapStartedSignalKind);

        public override BootstrapStartedSignalKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "bootstrapStarted")
            {
                return BootstrapStartedSignalKind.BootstrapStarted;
            }
            throw new Exception("Cannot unmarshal type BootstrapStartedSignalKind");
        }

        public override void Write(Utf8JsonWriter writer, BootstrapStartedSignalKind value, JsonSerializerOptions options)
        {
            if (value == BootstrapStartedSignalKind.BootstrapStarted)
            {
                JsonSerializer.Serialize(writer, "bootstrapStarted", options);
                return;
            }
            throw new Exception("Cannot marshal type BootstrapStartedSignalKind");
        }

        public static readonly BootstrapStartedSignalKindConverter Singleton = new BootstrapStartedSignalKindConverter();
    }

    internal class ChangeEventKindConverter : JsonConverter<ChangeEventKind>
    {
        public override bool CanConvert(Type t) => t == typeof(ChangeEventKind);

        public override ChangeEventKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "change")
            {
                return ChangeEventKind.Change;
            }
            throw new Exception("Cannot unmarshal type ChangeEventKind");
        }

        public override void Write(Utf8JsonWriter writer, ChangeEventKind value, JsonSerializerOptions options)
        {
            if (value == ChangeEventKind.Change)
            {
                JsonSerializer.Serialize(writer, "change", options);
                return;
            }
            throw new Exception("Cannot marshal type ChangeEventKind");
        }

        public static readonly ChangeEventKindConverter Singleton = new ChangeEventKindConverter();
    }

    internal class ControlSignalKindConverter : JsonConverter<ControlSignalKind>
    {
        public override bool CanConvert(Type t) => t == typeof(ControlSignalKind);

        public override ControlSignalKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "bootstrapCompleted":
                    return ControlSignalKind.BootstrapCompleted;
                case "bootstrapStarted":
                    return ControlSignalKind.BootstrapStarted;
                case "deleted":
                    return ControlSignalKind.Deleted;
                case "running":
                    return ControlSignalKind.Running;
                case "stopped":
                    return ControlSignalKind.Stopped;
            }
            throw new Exception("Cannot unmarshal type ControlSignalKind");
        }

        public override void Write(Utf8JsonWriter writer, ControlSignalKind value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ControlSignalKind.BootstrapCompleted:
                    JsonSerializer.Serialize(writer, "bootstrapCompleted", options);
                    return;
                case ControlSignalKind.BootstrapStarted:
                    JsonSerializer.Serialize(writer, "bootstrapStarted", options);
                    return;
                case ControlSignalKind.Deleted:
                    JsonSerializer.Serialize(writer, "deleted", options);
                    return;
                case ControlSignalKind.Running:
                    JsonSerializer.Serialize(writer, "running", options);
                    return;
                case ControlSignalKind.Stopped:
                    JsonSerializer.Serialize(writer, "stopped", options);
                    return;
            }
            throw new Exception("Cannot marshal type ControlSignalKind");
        }

        public static readonly ControlSignalKindConverter Singleton = new ControlSignalKindConverter();
    }

    internal class ControlEventKindConverter : JsonConverter<ControlEventKind>
    {
        public override bool CanConvert(Type t) => t == typeof(ControlEventKind);

        public override ControlEventKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "control")
            {
                return ControlEventKind.Control;
            }
            throw new Exception("Cannot unmarshal type ControlEventKind");
        }

        public override void Write(Utf8JsonWriter writer, ControlEventKind value, JsonSerializerOptions options)
        {
            if (value == ControlEventKind.Control)
            {
                JsonSerializer.Serialize(writer, "control", options);
                return;
            }
            throw new Exception("Cannot marshal type ControlEventKind");
        }

        public static readonly ControlEventKindConverter Singleton = new ControlEventKindConverter();
    }

    internal class DeletedSignalKindConverter : JsonConverter<DeletedSignalKind>
    {
        public override bool CanConvert(Type t) => t == typeof(DeletedSignalKind);

        public override DeletedSignalKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "deleted")
            {
                return DeletedSignalKind.Deleted;
            }
            throw new Exception("Cannot unmarshal type DeletedSignalKind");
        }

        public override void Write(Utf8JsonWriter writer, DeletedSignalKind value, JsonSerializerOptions options)
        {
            if (value == DeletedSignalKind.Deleted)
            {
                JsonSerializer.Serialize(writer, "deleted", options);
                return;
            }
            throw new Exception("Cannot marshal type DeletedSignalKind");
        }

        public static readonly DeletedSignalKindConverter Singleton = new DeletedSignalKindConverter();
    }

    internal class ResultEventKindConverter : JsonConverter<ResultEventKind>
    {
        public override bool CanConvert(Type t) => t == typeof(ResultEventKind);

        public override ResultEventKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "change":
                    return ResultEventKind.Change;
                case "control":
                    return ResultEventKind.Control;
            }
            throw new Exception("Cannot unmarshal type ResultEventKind");
        }

        public override void Write(Utf8JsonWriter writer, ResultEventKind value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ResultEventKind.Change:
                    JsonSerializer.Serialize(writer, "change", options);
                    return;
                case ResultEventKind.Control:
                    JsonSerializer.Serialize(writer, "control", options);
                    return;
            }
            throw new Exception("Cannot marshal type ResultEventKind");
        }

        public static readonly ResultEventKindConverter Singleton = new ResultEventKindConverter();
    }

    internal class RunningSignalKindConverter : JsonConverter<RunningSignalKind>
    {
        public override bool CanConvert(Type t) => t == typeof(RunningSignalKind);

        public override RunningSignalKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "running")
            {
                return RunningSignalKind.Running;
            }
            throw new Exception("Cannot unmarshal type RunningSignalKind");
        }

        public override void Write(Utf8JsonWriter writer, RunningSignalKind value, JsonSerializerOptions options)
        {
            if (value == RunningSignalKind.Running)
            {
                JsonSerializer.Serialize(writer, "running", options);
                return;
            }
            throw new Exception("Cannot marshal type RunningSignalKind");
        }

        public static readonly RunningSignalKindConverter Singleton = new RunningSignalKindConverter();
    }

    internal class StoppedSignalKindConverter : JsonConverter<StoppedSignalKind>
    {
        public override bool CanConvert(Type t) => t == typeof(StoppedSignalKind);

        public override StoppedSignalKind Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "stopped")
            {
                return StoppedSignalKind.Stopped;
            }
            throw new Exception("Cannot unmarshal type StoppedSignalKind");
        }

        public override void Write(Utf8JsonWriter writer, StoppedSignalKind value, JsonSerializerOptions options)
        {
            if (value == StoppedSignalKind.Stopped)
            {
                JsonSerializer.Serialize(writer, "stopped", options);
                return;
            }
            throw new Exception("Cannot marshal type StoppedSignalKind");
        }

        public static readonly StoppedSignalKindConverter Singleton = new StoppedSignalKindConverter();
    }

    internal class VersionsEnumConverter : JsonConverter<VersionsEnum>
    {
        public override bool CanConvert(Type t) => t == typeof(VersionsEnum);

        public override VersionsEnum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "v1")
            {
                return VersionsEnum.V1;
            }
            throw new Exception("Cannot unmarshal type VersionsEnum");
        }

        public override void Write(Utf8JsonWriter writer, VersionsEnum value, JsonSerializerOptions options)
        {
            if (value == VersionsEnum.V1)
            {
                JsonSerializer.Serialize(writer, "v1", options);
                return;
            }
            throw new Exception("Cannot marshal type VersionsEnum");
        }

        public static readonly VersionsEnumConverter Singleton = new VersionsEnumConverter();
    }
    
    public class DateOnlyConverter : JsonConverter<DateOnly>
    {
        private readonly string serializationFormat;
        public DateOnlyConverter() : this(null) { }

        public DateOnlyConverter(string? serializationFormat)
        {
                this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                var value = reader.GetString();
                return DateOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
                => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    public class TimeOnlyConverter : JsonConverter<TimeOnly>
    {
        private readonly string serializationFormat;

        public TimeOnlyConverter() : this(null) { }

        public TimeOnlyConverter(string? serializationFormat)
        {
                this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                var value = reader.GetString();
                return TimeOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
                => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string? _dateTimeFormat;
        private CultureInfo? _culture;

        public DateTimeStyles DateTimeStyles
        {
                get => _dateTimeStyles;
                set => _dateTimeStyles = value;
        }

        public string? DateTimeFormat
        {
                get => _dateTimeFormat ?? string.Empty;
                set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
                get => _culture ?? CultureInfo.CurrentCulture;
                set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
                string text;


                if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                        || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
                {
                        value = value.ToUniversalTime();
                }

                text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

                writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                string? dateText = reader.GetString();

                if (string.IsNullOrEmpty(dateText) == false)
                {
                        if (!string.IsNullOrEmpty(_dateTimeFormat))
                        {
                                return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                        }
                        else
                        {
                                return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                        }
                }
                else
                {
                        return default(DateTimeOffset);
                }
        }


        public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
