import { OrchestrationContext } from "../task/context/orchestration-context";
import * as pb from "../proto/orchestrator_service_pb";
import { CompletableTask } from "../task/completable-task";
import { TActivity } from "../types/activity.type";
import { TOrchestrator } from "../types/orchestrator.type";
import { Task } from "../task/task";
export declare class RuntimeOrchestrationContext extends OrchestrationContext {
    _generator?: Generator<Task<any>, any, any>;
    _previousTask?: Task<any>;
    _isReplaying: boolean;
    _isComplete: boolean;
    _result: any;
    _pendingActions: Record<number, pb.OrchestratorAction>;
    _pendingTasks: Record<number, CompletableTask<any>>;
    _sequenceNumber: any;
    _currentUtcDatetime: any;
    _instanceId: string;
    _completionStatus?: pb.OrchestrationStatus;
    _receivedEvents: Record<string, any[]>;
    _pendingEvents: Record<string, CompletableTask<any>[]>;
    _newInput?: any;
    _saveEvents: any;
    constructor(instanceId: string);
    get instanceId(): string;
    get currentUtcDateTime(): Date;
    get isReplaying(): boolean;
    /**
     * This is the main entry point for the orchestrator. It will run the generator
     * and return the first task to be executed. It is typically executed from the
     * orchestrator executor.
     *
     * @param generator
     */
    run(generator: Generator<Task<any>, any, any>): Promise<void>;
    resume(): Promise<void>;
    setComplete(result: any, status: pb.OrchestrationStatus, isResultEncoded?: boolean): void;
    setFailed(e: Error): void;
    setContinuedAsNew(newInput: any, saveEvents: boolean): void;
    getActions(): pb.OrchestratorAction[];
    nextSequenceNumber(): number;
    /**
     * Create a timer
     *
     * @param fireAt number Amount of seconds between now and when the timer should fire
     * @param fireAt Date The date when the timer should fire
     * @returns
     */
    createTimer(fireAt: number | Date): Task<any>;
    callActivity<TInput, TOutput>(activity: TActivity<TInput, TOutput> | string, input?: TInput | undefined): Task<TOutput>;
    callSubOrchestrator<TInput, TOutput>(orchestrator: TOrchestrator | string, input?: TInput | undefined, instanceId?: string | undefined): Task<TOutput>;
    waitForExternalEvent<T>(name: string): Task<T>;
    /**
     * Orchestrations can be continued as new. This API allows an  orchestration to restart itself from scratch, optionally with a new input.
     */
    continueAsNew(newInput: any, saveEvents?: boolean): void;
}
