"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Registry = void 0;
class Registry {
    constructor() {
        this._orchestrators = {};
        this._activities = {};
    }
    addOrchestrator(fn) {
        if (!fn) {
            throw new Error("An orchestrator function argument is required.");
        }
        const name = this._getFunctionName(fn);
        this.addNamedOrchestrator(name, fn);
        return name;
    }
    addNamedOrchestrator(name, fn) {
        if (!name) {
            throw new Error("A non-empty orchestrator name is required.");
        }
        if (name in this._orchestrators) {
            throw new Error(`A '${name}' orchestrator already exists.`);
        }
        this._orchestrators[name] = fn;
    }
    getOrchestrator(name) {
        if (!name) {
            return undefined;
        }
        return this._orchestrators[name];
    }
    addActivity(fn) {
        if (!fn) {
            throw new Error("An activity function argument is required.");
        }
        const name = this._getFunctionName(fn);
        this.addNamedActivity(name, fn);
        return name;
    }
    addNamedActivity(name, fn) {
        if (!name) {
            throw new Error("A non-empty activity name is required.");
        }
        if (name in this._activities) {
            throw new Error(`A '${name}' activity already exists.`);
        }
        this._activities[name] = fn;
    }
    getActivity(name) {
        return this._activities[name];
    }
    _getFunctionName(fn) {
        if (fn.name) {
            return fn.name;
        }
        const fnStr = fn.toString();
        const start = fnStr.indexOf("function") + "function".length;
        const end = fnStr.indexOf("(", start);
        return fnStr.slice(start, end).trim() || "";
    }
}
exports.Registry = Registry;
