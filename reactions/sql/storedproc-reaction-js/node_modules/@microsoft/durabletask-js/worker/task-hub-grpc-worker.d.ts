import * as grpc from "@grpc/grpc-js";
import { TActivity } from "../types/activity.type";
import { TInput } from "../types/input.type";
import { TOrchestrator } from "../types/orchestrator.type";
import { TOutput } from "../types/output.type";
export declare class TaskHubGrpcWorker {
    private _responseStream;
    private _registry;
    private _hostAddress?;
    private _tls?;
    private _grpcChannelOptions?;
    private _isRunning;
    private _stub;
    constructor(hostAddress?: string, options?: grpc.ChannelOptions, useTLS?: boolean);
    /**
     * Registers an orchestrator function with the worker.
     *
     * @param fn
     * @returns
     */
    addOrchestrator(fn: TOrchestrator): string;
    /**
     * Registers an named orchestrator function with the worker.
     *
     * @param fn
     * @returns
     */
    addNamedOrchestrator(name: string, fn: TOrchestrator): string;
    /**
     * Registers an activity function with the worker.
     *
     * @param fn
     * @returns
     */
    addActivity(fn: TActivity<TInput, TOutput>): string;
    /**
     * Registers an named activity function with the worker.
     *
     * @param fn
     * @returns
     */
    addNamedActivity(name: string, fn: TActivity<TInput, TOutput>): string;
    /**
     * In node.js we don't require a new thread as we have a main event loop
     * Therefore, we open the stream and simply listen through the eventemitter behind the scenes
     */
    start(): Promise<void>;
    /**
     * Stop the worker and wait for any pending work items to complete
     */
    stop(): Promise<void>;
    /**
     *
     */
    private _executeOrchestrator;
    /**
     *
     */
    private _executeActivity;
}
