"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskHubGrpcWorker = void 0;
const pb = __importStar(require("../proto/orchestrator_service_pb"));
const registry_1 = require("./registry");
const client_grpc_1 = require("../client/client-grpc");
const util_1 = require("util");
const empty_pb_1 = require("google-protobuf/google/protobuf/empty_pb");
const pbh = __importStar(require("../utils/pb-helper.util"));
const orchestration_executor_1 = require("./orchestration-executor");
const activity_executor_1 = require("./activity-executor");
const wrappers_pb_1 = require("google-protobuf/google/protobuf/wrappers_pb");
class TaskHubGrpcWorker {
    constructor(hostAddress, options, useTLS) {
        this._registry = new registry_1.Registry();
        this._hostAddress = hostAddress;
        this._tls = useTLS;
        this._grpcChannelOptions = options;
        this._responseStream = null;
        this._isRunning = false;
        this._stub = null;
    }
    /**
     * Registers an orchestrator function with the worker.
     *
     * @param fn
     * @returns
     */
    addOrchestrator(fn) {
        if (this._isRunning) {
            throw new Error("Cannot add orchestrator while worker is running.");
        }
        return this._registry.addOrchestrator(fn);
    }
    /**
     * Registers an named orchestrator function with the worker.
     *
     * @param fn
     * @returns
     */
    addNamedOrchestrator(name, fn) {
        if (this._isRunning) {
            throw new Error("Cannot add orchestrator while worker is running.");
        }
        this._registry.addNamedOrchestrator(name, fn);
        return name;
    }
    /**
     * Registers an activity function with the worker.
     *
     * @param fn
     * @returns
     */
    addActivity(fn) {
        if (this._isRunning) {
            throw new Error("Cannot add activity while worker is running.");
        }
        return this._registry.addActivity(fn);
    }
    /**
     * Registers an named activity function with the worker.
     *
     * @param fn
     * @returns
     */
    addNamedActivity(name, fn) {
        if (this._isRunning) {
            throw new Error("Cannot add activity while worker is running.");
        }
        this._registry.addNamedActivity(name, fn);
        return name;
    }
    /**
     * In node.js we don't require a new thread as we have a main event loop
     * Therefore, we open the stream and simply listen through the eventemitter behind the scenes
     */
    async start() {
        const client = new client_grpc_1.GrpcClient(this._hostAddress, this._grpcChannelOptions, this._tls);
        if (this._isRunning) {
            throw new Error("The worker is already running.");
        }
        // send a "Hello" message to the sidecar to ensure that it's listening
        const prom = (0, util_1.promisify)(client.stub.hello.bind(client.stub));
        await prom(new empty_pb_1.Empty());
        // Stream work items from the sidecar
        const stubGetWorkItemsReq = new pb.GetWorkItemsRequest();
        this._stub = client.stub;
        this._responseStream = client.stub.getWorkItems(stubGetWorkItemsReq);
        console.log(`Successfully connected to ${this._hostAddress}. Waiting for work items...`);
        // Wait for a work item to be received
        this._responseStream.on("data", (workItem) => {
            if (workItem.hasOrchestratorrequest()) {
                console.log(`Received "Orchestrator Request" work item with instance id '${workItem
                    ?.getOrchestratorrequest()
                    ?.getInstanceid()}'`);
                this._executeOrchestrator(workItem.getOrchestratorrequest(), client.stub);
            }
            else if (workItem.hasActivityrequest()) {
                console.log(`Received "Activity Request" work item`);
                this._executeActivity(workItem.getActivityrequest(), client.stub);
            }
            else {
                console.log(`Received unknown work item`);
            }
        });
        // Wait for the stream to end or error
        this._responseStream.on("end", () => {
            console.log("Stream ended");
        });
        this._responseStream.on("error", (err) => {
            console.log("Stream error", err);
        });
        this._isRunning = true;
    }
    /**
     * Stop the worker and wait for any pending work items to complete
     */
    async stop() {
        if (!this._isRunning) {
            throw new Error("The worker is not running.");
        }
        this._responseStream?.cancel();
        this._responseStream?.destroy();
        this._stub?.close();
        this._isRunning = false;
        // Wait a bit to let the async operations finish
        // https://github.com/grpc/grpc-node/issues/1563#issuecomment-829483711
        await new Promise((resolve) => setTimeout(resolve, 1000));
    }
    /**
     *
     */
    async _executeOrchestrator(req, stub) {
        const instanceId = req.getInstanceid();
        if (!instanceId) {
            throw new Error(`Could not execute the orchestrator as the instanceId was not provided (${instanceId})`);
        }
        let res;
        try {
            const executor = new orchestration_executor_1.OrchestrationExecutor(this._registry);
            const actions = await executor.execute(req.getInstanceid(), req.getPasteventsList(), req.getNeweventsList());
            res = new pb.OrchestratorResponse();
            res.setInstanceid(req.getInstanceid());
            res.setActionsList(actions);
        }
        catch (e) {
            console.error(e);
            console.log(`An error occurred while trying to execute instance '${req.getInstanceid()}': ${e.message}`);
            const failureDetails = pbh.newFailureDetails(e);
            const actions = [
                pbh.newCompleteOrchestrationAction(-1, pb.OrchestrationStatus.ORCHESTRATION_STATUS_FAILED, failureDetails?.toString()),
            ];
            res = new pb.OrchestratorResponse();
            res.setInstanceid(req.getInstanceid());
            res.setActionsList(actions);
        }
        try {
            const stubCompleteOrchestratorTask = (0, util_1.promisify)(stub.completeOrchestratorTask.bind(stub));
            await stubCompleteOrchestratorTask(res);
        }
        catch (e) {
            console.error(`An error occurred while trying to complete instance '${req.getInstanceid()}': ${e?.message}`);
        }
    }
    /**
     *
     */
    async _executeActivity(req, stub) {
        const instanceId = req.getOrchestrationinstance()?.getInstanceid();
        if (!instanceId) {
            throw new Error("Activity request does not contain an orchestration instance id");
        }
        let res;
        try {
            const executor = new activity_executor_1.ActivityExecutor(this._registry);
            const result = await executor.execute(instanceId, req.getName(), req.getTaskid(), req.getInput()?.toString() ?? "");
            const s = new wrappers_pb_1.StringValue();
            s.setValue(result?.toString() ?? "");
            res = new pb.ActivityResponse();
            res.setInstanceid(instanceId);
            res.setTaskid(req.getTaskid());
            res.setResult(s);
        }
        catch (e) {
            console.error(e);
            console.log(`An error occurred while trying to execute activity '${req.getName()}': ${e.message}`);
            const failureDetails = pbh.newFailureDetails(e);
            res = new pb.ActivityResponse();
            res.setTaskid(req.getTaskid());
            res.setFailuredetails(failureDetails);
        }
        try {
            const stubCompleteActivityTask = (0, util_1.promisify)(stub.completeActivityTask.bind(stub));
            await stubCompleteActivityTask(res);
        }
        catch (e) {
            console.error(`Failed to deliver activity response for '${req.getName()}#${req.getTaskid()}' of orchestration ID '${instanceId}' to sidecar: ${e?.message}`);
        }
    }
}
exports.TaskHubGrpcWorker = TaskHubGrpcWorker;
