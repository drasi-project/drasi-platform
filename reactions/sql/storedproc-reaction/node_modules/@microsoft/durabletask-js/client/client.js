"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskHubGrpcClient = void 0;
const wrappers_pb_1 = require("google-protobuf/google/protobuf/wrappers_pb");
const timestamp_pb_1 = require("google-protobuf/google/protobuf/timestamp_pb");
const pb = __importStar(require("../proto/orchestrator_service_pb"));
const task_1 = require("../task");
const crypto_1 = require("crypto");
const util_1 = require("util");
const orchestration_1 = require("../orchestration");
const client_grpc_1 = require("./client-grpc");
const orchestration_status_enum_1 = require("../orchestration/enum/orchestration-status.enum");
const timeout_error_1 = require("../exception/timeout-error");
const orchestration_purge_result_1 = require("../orchestration/orchestration-purge-result");
class TaskHubGrpcClient {
    constructor(hostAddress, option, useTLS) {
        this._stub = new client_grpc_1.GrpcClient(hostAddress, option, useTLS).stub;
    }
    async stop() {
        await this._stub.close();
        // Wait a bit to let the async operations finish
        // https://github.com/grpc/grpc-node/issues/1563#issuecomment-829483711
        await new Promise((resolve) => setTimeout(resolve, 1000));
    }
    /**
     * Schedules a new orchestrator using the DurableTask client.
     *
     * @param {TOrchestrator | string} orchestrator - The orchestrator or the name of the orchestrator to be scheduled.
     * @return {Promise<string>} A Promise resolving to the unique ID of the scheduled orchestrator instance.
     */
    async scheduleNewOrchestration(orchestrator, input, instanceId, startAt) {
        let name;
        if (typeof orchestrator === "string") {
            name = orchestrator;
        }
        else {
            name = (0, task_1.getName)(orchestrator);
        }
        const req = new pb.CreateInstanceRequest();
        req.setName(name);
        req.setInstanceid(instanceId ?? (0, crypto_1.randomUUID)());
        const i = new wrappers_pb_1.StringValue();
        i.setValue(JSON.stringify(input));
        const ts = new timestamp_pb_1.Timestamp();
        ts.fromDate(new Date(startAt?.getTime() ?? 0));
        req.setInput(i);
        req.setScheduledstarttimestamp(ts);
        console.log(`Starting new ${name} instance with ID = ${req.getInstanceid()}`);
        const prom = (0, util_1.promisify)(this._stub.startInstance.bind(this._stub));
        const res = (await prom(req));
        return res.getInstanceid();
    }
    /**
     * Fetches orchestrator instance metadata from the configured durable store.
     *
     * @param {string} instanceId - The unique identifier of the orchestrator instance to fetch.
     * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
     *                                       inputs, outputs, and custom status (true) or omit them (false).
     * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to a metadata record describing
     *                                              the orchestrator instance and its execution status, or undefined
     *                                              if the instance is not found.
     */
    async getOrchestrationState(instanceId, fetchPayloads = true) {
        const req = new pb.GetInstanceRequest();
        req.setInstanceid(instanceId);
        req.setGetinputsandoutputs(fetchPayloads);
        const prom = (0, util_1.promisify)(this._stub.getInstance.bind(this._stub));
        const res = (await prom(req));
        return (0, orchestration_1.newOrchestrationState)(req.getInstanceid(), res);
    }
    /**
     * Waits for a orchestrator to start running and returns a {@link OrchestrationState} object
     * containing metadata about the started instance, and optionally, its input, output,
     * and custom status payloads.
     *
     * A "started" orchestrator instance refers to any instance not in the Pending state.
     *
     * If a orchestrator instance is already running when this method is called, it returns immediately.
     *
     * @param {string} instanceId - The unique identifier of the orchestrator instance to wait for.
     * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
     *                                  inputs, outputs (true) or omit them (false).
     * @param {number} timeout - The amount of time, in seconds, to wait for the orchestrator instance to start.
     * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to the orchestrator instance metadata
     *                                               or undefined if no such instance is found.
     */
    async waitForOrchestrationStart(instanceId, fetchPayloads = false, timeout = 60) {
        const req = new pb.GetInstanceRequest();
        req.setInstanceid(instanceId);
        req.setGetinputsandoutputs(fetchPayloads);
        try {
            const prom = (0, util_1.promisify)(this._stub.waitForInstanceStart.bind(this._stub));
            // Execute the request and wait for the first response or timeout
            const res = (await Promise.race([
                prom(req),
                new Promise((_, reject) => setTimeout(() => reject(new timeout_error_1.TimeoutError()), timeout * 1000)),
            ]));
            return (0, orchestration_1.newOrchestrationState)(req.getInstanceid(), res);
        }
        catch (e) {
            console.log(e);
            throw e;
        }
    }
    /**
     * Waits for a orchestrator to complete running and returns a {@link OrchestrationState} object
     * containing metadata about the completed instance, and optionally, its input, output,
     * and custom status payloads.
     *
     * A "completed" orchestrator instance refers to any instance in one of the terminal states.
     * For example, the Completed, Failed, or Terminated states.
     *
     * If a orchestrator instance is already running when this method is called, it returns immediately.
     *
     * @param {string} instanceId - The unique identifier of the orchestrator instance to wait for.
     * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
     *                                  inputs, outputs (true) or omit them (false).
     * @param {number} timeout - The amount of time, in seconds, to wait for the orchestrator instance to start.
     * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to the orchestrator instance metadata
     *                                               or undefined if no such instance is found.
     */
    async waitForOrchestrationCompletion(instanceId, fetchPayloads = true, timeout = 60) {
        const req = new pb.GetInstanceRequest();
        req.setInstanceid(instanceId);
        req.setGetinputsandoutputs(fetchPayloads);
        try {
            console.info(`Waiting ${timeout} seconds for instance ${instanceId} to complete...`);
            const prom = (0, util_1.promisify)(this._stub.waitForInstanceCompletion.bind(this._stub));
            // Execute the request and wait for the first response or timeout
            const res = (await Promise.race([
                prom(req),
                new Promise((_, reject) => setTimeout(() => reject(new timeout_error_1.TimeoutError()), timeout * 1000)),
            ]));
            const state = (0, orchestration_1.newOrchestrationState)(req.getInstanceid(), res);
            if (!state) {
                return undefined;
            }
            let details;
            if (state.runtimeStatus === orchestration_status_enum_1.OrchestrationStatus.FAILED && state.failureDetails) {
                details = state.failureDetails;
                console.info(`Instance ${instanceId} failed: [${details.errorType}] ${details.message}`);
            }
            else if (state.runtimeStatus === orchestration_status_enum_1.OrchestrationStatus.TERMINATED) {
                console.info(`Instance ${instanceId} was terminated`);
            }
            else if (state.runtimeStatus === orchestration_status_enum_1.OrchestrationStatus.COMPLETED) {
                console.info(`Instance ${instanceId} completed`);
            }
            return state;
        }
        catch (e) {
            console.log(e);
            throw e;
        }
    }
    /**
     * Sends an event notification message to an awaiting orchestrator instance.
     *
     * This method triggers the specified event in a running orchestrator instance,
     * allowing the orchestrator to respond to the event if it has defined event handlers.
     *
     * @param {string} instanceId - The unique identifier of the orchestrator instance that will handle the event.
     * @param {string} eventName - The name of the event. Event names are case-insensitive.
     * @param {any} [data] - An optional serializable data payload to include with the event.
     */
    async raiseOrchestrationEvent(instanceId, eventName, data = null) {
        const req = new pb.RaiseEventRequest();
        req.setInstanceid(instanceId);
        req.setName(eventName);
        const i = new wrappers_pb_1.StringValue();
        i.setValue(JSON.stringify(data));
        req.setInput(i);
        console.log(`Raising event '${eventName}' for instance '${instanceId}'`);
        const prom = (0, util_1.promisify)(this._stub.raiseEvent.bind(this._stub));
        await prom(req);
    }
    /**
     * Terminates the orchestrator associated with the provided instance id.
     *
     * @param {string} instanceId - orchestrator instance id to terminate.
     * @param {any} output - The optional output to set for the terminated orchestrator instance.
     */
    async terminateOrchestration(instanceId, output = null) {
        const req = new pb.TerminateRequest();
        req.setInstanceid(instanceId);
        const i = new wrappers_pb_1.StringValue();
        i.setValue(JSON.stringify(output));
        req.setOutput(i);
        console.log(`Terminating '${instanceId}'`);
        const prom = (0, util_1.promisify)(this._stub.terminateInstance.bind(this._stub));
        await prom(req);
    }
    async suspendOrchestration(instanceId) {
        const req = new pb.SuspendRequest();
        req.setInstanceid(instanceId);
        console.log(`Suspending '${instanceId}'`);
        const prom = (0, util_1.promisify)(this._stub.suspendInstance.bind(this._stub));
        await prom(req);
    }
    async resumeOrchestration(instanceId) {
        const req = new pb.ResumeRequest();
        req.setInstanceid(instanceId);
        console.log(`Resuming '${instanceId}'`);
        const prom = (0, util_1.promisify)(this._stub.resumeInstance.bind(this._stub));
        await prom(req);
    }
    /**
     * Purges orchestration instance metadata from the durable store.
     *
     * This method can be used to permanently delete orchestration metadata from the underlying storage provider,
     * including any stored inputs, outputs, and orchestration history records. This is often useful for implementing
     * data retention policies and for keeping storage costs minimal. Only orchestration instances in the
     * `Completed`, `Failed`, or `Terminated` state can be purged.
     *
     * If the target orchestration instance is not found in the data store, or if the instance is found but not in a
     * terminal state, then the returned {@link PurgeResult} will report that zero instances were purged.
     * Otherwise, the existing data will be purged, and the returned {@link PurgeResult} will report that one instance
     * was purged.
     *
     * @param value - The unique ID of the orchestration instance to purge or orchestration instance filter criteria used
     * to determine which instances to purge.
     * @returns A Promise that resolves to a {@link PurgeResult} or `undefined` if the purge operation was not successful.
     */
    async purgeOrchestration(value) {
        let res;
        if (typeof value === `string`) {
            const instanceId = value;
            const req = new pb.PurgeInstancesRequest();
            req.setInstanceid(instanceId);
            console.log(`Purging Instance '${instanceId}'`);
            const prom = (0, util_1.promisify)(this._stub.purgeInstances.bind(this._stub));
            res = (await prom(req));
        }
        else {
            const purgeInstanceCriteria = value;
            const req = new pb.PurgeInstancesRequest();
            const filter = new pb.PurgeInstanceFilter();
            const createdTimeFrom = purgeInstanceCriteria.getCreatedTimeFrom();
            if (createdTimeFrom != undefined) {
                const timestamp = new timestamp_pb_1.Timestamp();
                timestamp.fromDate(createdTimeFrom);
                filter.setCreatedtimefrom(timestamp);
            }
            const createdTimeTo = purgeInstanceCriteria.getCreatedTimeTo();
            if (createdTimeTo != undefined) {
                const timestamp = new timestamp_pb_1.Timestamp();
                timestamp.fromDate(createdTimeTo);
                filter.setCreatedtimeto(timestamp);
            }
            const runtimeStatusList = purgeInstanceCriteria.getRuntimeStatusList();
            for (const status of runtimeStatusList) {
                filter.addRuntimestatus((0, orchestration_status_enum_1.toProtobuf)(status));
            }
            req.setPurgeinstancefilter(filter);
            const timeout = purgeInstanceCriteria.getTimeout();
            console.log("Purging Instance using purging criteria");
            const prom = (0, util_1.promisify)(this._stub.purgeInstances.bind(this._stub));
            // Execute the request and wait for the first response or timeout
            res = (await Promise.race([
                prom(req),
                new Promise((_, reject) => setTimeout(() => reject(new timeout_error_1.TimeoutError()), timeout)),
            ]));
        }
        if (!res) {
            return;
        }
        return new orchestration_purge_result_1.PurgeResult(res.getDeletedinstancecount());
    }
}
exports.TaskHubGrpcClient = TaskHubGrpcClient;
