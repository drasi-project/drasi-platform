import { TOrchestrator } from "../types/orchestrator.type";
import { TInput } from "../types/input.type";
import { OrchestrationState } from "../orchestration/orchestration-state";
import { PurgeResult } from "../orchestration/orchestration-purge-result";
import { PurgeInstanceCriteria } from "../orchestration/orchestration-purge-criteria";
import * as grpc from "@grpc/grpc-js";
export declare class TaskHubGrpcClient {
    private _stub;
    constructor(hostAddress?: string, option?: grpc.ChannelOptions, useTLS?: boolean);
    stop(): Promise<void>;
    /**
     * Schedules a new orchestrator using the DurableTask client.
     *
     * @param {TOrchestrator | string} orchestrator - The orchestrator or the name of the orchestrator to be scheduled.
     * @return {Promise<string>} A Promise resolving to the unique ID of the scheduled orchestrator instance.
     */
    scheduleNewOrchestration(orchestrator: TOrchestrator | string, input?: TInput, instanceId?: string, startAt?: Date): Promise<string>;
    /**
     * Fetches orchestrator instance metadata from the configured durable store.
     *
     * @param {string} instanceId - The unique identifier of the orchestrator instance to fetch.
     * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
     *                                       inputs, outputs, and custom status (true) or omit them (false).
     * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to a metadata record describing
     *                                              the orchestrator instance and its execution status, or undefined
     *                                              if the instance is not found.
     */
    getOrchestrationState(instanceId: string, fetchPayloads?: boolean): Promise<OrchestrationState | undefined>;
    /**
     * Waits for a orchestrator to start running and returns a {@link OrchestrationState} object
     * containing metadata about the started instance, and optionally, its input, output,
     * and custom status payloads.
     *
     * A "started" orchestrator instance refers to any instance not in the Pending state.
     *
     * If a orchestrator instance is already running when this method is called, it returns immediately.
     *
     * @param {string} instanceId - The unique identifier of the orchestrator instance to wait for.
     * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
     *                                  inputs, outputs (true) or omit them (false).
     * @param {number} timeout - The amount of time, in seconds, to wait for the orchestrator instance to start.
     * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to the orchestrator instance metadata
     *                                               or undefined if no such instance is found.
     */
    waitForOrchestrationStart(instanceId: string, fetchPayloads?: boolean, timeout?: number): Promise<OrchestrationState | undefined>;
    /**
     * Waits for a orchestrator to complete running and returns a {@link OrchestrationState} object
     * containing metadata about the completed instance, and optionally, its input, output,
     * and custom status payloads.
     *
     * A "completed" orchestrator instance refers to any instance in one of the terminal states.
     * For example, the Completed, Failed, or Terminated states.
     *
     * If a orchestrator instance is already running when this method is called, it returns immediately.
     *
     * @param {string} instanceId - The unique identifier of the orchestrator instance to wait for.
     * @param {boolean} fetchPayloads - Indicates whether to fetch the orchestrator instance's
     *                                  inputs, outputs (true) or omit them (false).
     * @param {number} timeout - The amount of time, in seconds, to wait for the orchestrator instance to start.
     * @returns {Promise<OrchestrationState | undefined>} A Promise that resolves to the orchestrator instance metadata
     *                                               or undefined if no such instance is found.
     */
    waitForOrchestrationCompletion(instanceId: string, fetchPayloads?: boolean, timeout?: number): Promise<OrchestrationState | undefined>;
    /**
     * Sends an event notification message to an awaiting orchestrator instance.
     *
     * This method triggers the specified event in a running orchestrator instance,
     * allowing the orchestrator to respond to the event if it has defined event handlers.
     *
     * @param {string} instanceId - The unique identifier of the orchestrator instance that will handle the event.
     * @param {string} eventName - The name of the event. Event names are case-insensitive.
     * @param {any} [data] - An optional serializable data payload to include with the event.
     */
    raiseOrchestrationEvent(instanceId: string, eventName: string, data?: any): Promise<void>;
    /**
     * Terminates the orchestrator associated with the provided instance id.
     *
     * @param {string} instanceId - orchestrator instance id to terminate.
     * @param {any} output - The optional output to set for the terminated orchestrator instance.
     */
    terminateOrchestration(instanceId: string, output?: any): Promise<void>;
    suspendOrchestration(instanceId: string): Promise<void>;
    resumeOrchestration(instanceId: string): Promise<void>;
    /**
     * Purges orchestration instance metadata from the durable store.
     *
     * This method can be used to permanently delete orchestration metadata from the underlying storage provider,
     * including any stored inputs, outputs, and orchestration history records. This is often useful for implementing
     * data retention policies and for keeping storage costs minimal. Only orchestration instances in the
     * `Completed`, `Failed`, or `Terminated` state can be purged.
     *
     * If the target orchestration instance is not found in the data store, or if the instance is found but not in a
     * terminal state, then the returned {@link PurgeResult} will report that zero instances were purged.
     * Otherwise, the existing data will be purged, and the returned {@link PurgeResult} will report that one instance
     * was purged.
     *
     * @param value - The unique ID of the orchestration instance to purge or orchestration instance filter criteria used
     * to determine which instances to purge.
     * @returns A Promise that resolves to a {@link PurgeResult} or `undefined` if the purge operation was not successful.
     */
    purgeOrchestration(value: string | PurgeInstanceCriteria): Promise<PurgeResult | undefined>;
}
