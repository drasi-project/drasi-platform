"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrchestrationExecutor = void 0;
const _1 = require(".");
const pb = __importStar(require("../proto/orchestrator_service_pb"));
const task_1 = require("../task");
const orchestration_state_error_1 = require("../task/exception/orchestration-state-error");
const enum_util_1 = require("../utils/enum.util");
const pb_helper_util_1 = require("../utils/pb-helper.util");
const orchestrator_not_registered_error_1 = require("./exception/orchestrator-not-registered-error");
const stop_iteration_error_1 = require("./exception/stop-iteration-error");
const runtime_orchestration_context_1 = require("./runtime-orchestration-context");
class OrchestrationExecutor {
    constructor(registry) {
        this._registry = registry;
        this._generator = undefined;
        this._isSuspended = false;
        this._suspendedEvents = [];
    }
    async execute(instanceId, oldEvents, newEvents) {
        if (!newEvents?.length) {
            throw new orchestration_state_error_1.OrchestrationStateError("The new history event list must have at least one event in it");
        }
        const ctx = new runtime_orchestration_context_1.RuntimeOrchestrationContext(instanceId);
        try {
            // Rebuild the local state by replaying the history events into the orchestrator function
            console.info(`${instanceId}: Rebuilding local state with ${oldEvents.length} history event...`);
            ctx._isReplaying = true;
            for (const oldEvent of oldEvents) {
                await this.processEvent(ctx, oldEvent);
            }
            // Get new actions by executing newly received events into the orchestrator function
            const summary = (0, _1.getNewEventSummary)(newEvents);
            console.info(`${instanceId}: Processing ${newEvents.length} new history event(s): ${summary}`);
            ctx._isReplaying = false;
            for (const newEvent of newEvents) {
                await this.processEvent(ctx, newEvent);
            }
        }
        catch (e) {
            ctx.setFailed(e);
        }
        if (!ctx._isComplete) {
            const taskCount = Object.keys(ctx._pendingTasks).length;
            const eventCount = Object.keys(ctx._pendingEvents).length;
            console.log(`${instanceId}: Waiting for ${taskCount} task(s) and ${eventCount} event(s) to complete...`);
        }
        else if (ctx._completionStatus &&
            ctx._completionStatus !== pb.OrchestrationStatus.ORCHESTRATION_STATUS_CONTINUED_AS_NEW) {
            const completionStatusStr = (0, pb_helper_util_1.getOrchestrationStatusStr)(ctx._completionStatus);
            console.log(`${instanceId}: Orchestration completed with status ${completionStatusStr}`);
        }
        const actions = ctx.getActions();
        console.log(`${instanceId}: Returning ${actions.length} action(s)`);
        return actions;
    }
    async processEvent(ctx, event) {
        // Check if we are suspended to see if we need to buffer the event until we are resumed
        if (this._isSuspended && (0, _1.isSuspendable)(event)) {
            console.log("Suspended, buffering event");
            this._suspendedEvents.push(event);
            return;
        }
        const eventType = event.getEventtypeCase();
        const eventTypeName = (0, enum_util_1.enumValueToKey)(pb.HistoryEvent.EventtypeCase, eventType);
        // console.debug(`DEBUG - Processing event type ${eventTypeName} (${event.getEventtypeCase()})`);
        // Process the event type
        try {
            switch (eventType) {
                case pb.HistoryEvent.EventtypeCase.ORCHESTRATORSTARTED:
                    ctx._currentUtcDatetime = event.getTimestamp()?.toDate();
                    break;
                case pb.HistoryEvent.EventtypeCase.EXECUTIONSTARTED:
                    {
                        // TODO: Check if we already started the orchestration
                        const executionStartedEvent = event.getExecutionstarted();
                        const fn = this._registry.getOrchestrator(executionStartedEvent ? executionStartedEvent.getName() : undefined);
                        if (!fn) {
                            throw new orchestrator_not_registered_error_1.OrchestratorNotRegisteredError(executionStartedEvent?.getName());
                        }
                        // Deserialize the input, if any
                        let input = undefined;
                        if (executionStartedEvent?.getInput() && executionStartedEvent?.getInput()?.toString() !== "") {
                            input = JSON.parse(executionStartedEvent.getInput()?.toString() || "{}");
                        }
                        // This does not execute the generator, it creates it
                        // since we create an async iterator, we await the creation (so we can use await in the generator itself beside yield)
                        const result = await fn(ctx, input);
                        const isAsyncGenerator = typeof result?.[Symbol.asyncIterator] === "function";
                        if (isAsyncGenerator) {
                            // Start the orchestrator's generator function
                            await ctx.run(result);
                        }
                        else {
                            const resultType = Object.prototype.toString.call(result);
                            console.log(`An orchestrator was returned that doesn't schedule any tasks (type = ${resultType})`);
                            // This is an orchestrator that doesn't schedule any tasks
                            ctx.setComplete(result, pb.OrchestrationStatus.ORCHESTRATION_STATUS_COMPLETED);
                        }
                    }
                    break;
                case pb.HistoryEvent.EventtypeCase.TIMERCREATED:
                    // This history event confirms that the timer was successfully scheduled. Remove the timerCreated event from the pending action list so we don't schedule it again.
                    {
                        const timerId = event.getEventid();
                        const action = ctx._pendingActions[timerId];
                        // Delete it
                        delete ctx._pendingActions[timerId];
                        const isTimerAction = action?.getCreatetimer();
                        if (!action) {
                            throw (0, _1.getNonDeterminismError)(timerId, (0, task_1.getName)(ctx.createTimer));
                        }
                        else if (!isTimerAction) {
                            const expectedMethodName = (0, task_1.getName)(ctx.createTimer);
                            throw (0, _1.getWrongActionTypeError)(timerId, expectedMethodName, action);
                        }
                    }
                    break;
                case pb.HistoryEvent.EventtypeCase.TIMERFIRED:
                    {
                        const timerFiredEvent = event.getTimerfired();
                        const timerId = timerFiredEvent ? timerFiredEvent.getTimerid() : undefined;
                        let timerTask;
                        if (timerId) {
                            timerTask = ctx._pendingTasks[timerId];
                            delete ctx._pendingTasks[timerId];
                        }
                        if (!timerTask) {
                            // TODO: Should this be an error? When would it ever happen?
                            if (!ctx._isReplaying) {
                                console.warn(`${ctx._instanceId}: Ignoring unexpected timerFired event with ID = ${timerId}`);
                            }
                            return;
                        }
                        timerTask.complete(undefined);
                        await ctx.resume();
                    }
                    break;
                // This history event confirms that the activity execution was successfully scheduled. Remove the taskscheduled event from the pending action list so we don't schedule it again.
                case pb.HistoryEvent.EventtypeCase.TASKSCHEDULED:
                    {
                        const taskId = event.getEventid();
                        const action = ctx._pendingActions[taskId];
                        delete ctx._pendingActions[taskId];
                        const isScheduleTaskAction = action?.hasScheduletask();
                        if (!action) {
                            throw (0, _1.getNonDeterminismError)(taskId, (0, task_1.getName)(ctx.callActivity));
                        }
                        else if (!isScheduleTaskAction) {
                            const expectedMethodName = (0, task_1.getName)(ctx.callActivity);
                            throw (0, _1.getWrongActionTypeError)(taskId, expectedMethodName, action);
                        }
                        else if (action.getScheduletask()?.getName() != event.getTaskscheduled()?.getName()) {
                            throw (0, _1.getWrongActionNameError)(taskId, (0, task_1.getName)(ctx.callActivity), event.getTaskscheduled()?.getName(), action.getScheduletask()?.getName());
                        }
                    }
                    break;
                // This history event contains the result of a completed activity task
                case pb.HistoryEvent.EventtypeCase.TASKCOMPLETED:
                    {
                        const taskCompletedEvent = event.getTaskcompleted();
                        const taskId = taskCompletedEvent ? taskCompletedEvent.getTaskscheduledid() : undefined;
                        let activityTask;
                        if (taskId) {
                            activityTask = ctx._pendingTasks[taskId];
                            delete ctx._pendingTasks[taskId];
                        }
                        if (!activityTask) {
                            // TODO: Should this be an error? When would it ever happen?
                            if (!ctx._isReplaying) {
                                console.warn(`${ctx._instanceId}: Ignoring unexpected taskCompleted event with ID = ${taskId}`);
                            }
                            return;
                        }
                        let result;
                        if (!(0, pb_helper_util_1.isEmpty)(event.getTaskcompleted()?.getResult())) {
                            result = JSON.parse(event.getTaskcompleted()?.getResult()?.toString() || "");
                        }
                        activityTask.complete(result);
                        await ctx.resume();
                    }
                    break;
                case pb.HistoryEvent.EventtypeCase.TASKFAILED:
                    {
                        const taskFailedEvent = event.getTaskfailed();
                        const taskId = taskFailedEvent ? taskFailedEvent.getTaskscheduledid() : undefined;
                        let activityTask;
                        if (taskId) {
                            activityTask = ctx._pendingTasks[taskId];
                            delete ctx._pendingTasks[taskId];
                        }
                        if (!activityTask) {
                            // TODO: Should this be an error? When would it ever happen?
                            if (!ctx._isReplaying) {
                                console.warn(`${ctx._instanceId}: Ignoring unexpected taskFailed event with ID = ${taskId}`);
                            }
                            return;
                        }
                        activityTask.fail(`${ctx._instanceId}: Activity task #${taskId} failed: ${event
                            .getTaskfailed()
                            ?.getFailuredetails()
                            ?.getErrormessage()}`, event.getTaskfailed()?.getFailuredetails());
                        await ctx.resume();
                    }
                    break;
                // This history event confirms that the sub-orcehstration execution was successfully scheduled. Remove the subOrchestrationInstanceCreated event from the pending action list so we don't schedule it again.
                case pb.HistoryEvent.EventtypeCase.SUBORCHESTRATIONINSTANCECREATED:
                    {
                        const taskId = event.getEventid();
                        const action = ctx._pendingActions[taskId];
                        delete ctx._pendingActions[taskId];
                        const isCreateSubOrchestrationAction = action?.hasCreatesuborchestration();
                        if (!action) {
                            throw (0, _1.getNonDeterminismError)(taskId, (0, task_1.getName)(ctx.callSubOrchestrator));
                        }
                        else if (!isCreateSubOrchestrationAction) {
                            const expectedMethodName = (0, task_1.getName)(ctx.callSubOrchestrator);
                            throw (0, _1.getWrongActionTypeError)(taskId, expectedMethodName, action);
                        }
                        else if (action.getCreatesuborchestration()?.getName() != event.getSuborchestrationinstancecreated()?.getName()) {
                            throw (0, _1.getWrongActionNameError)(taskId, (0, task_1.getName)(ctx.callSubOrchestrator), action.getCreatesuborchestration()?.getName(), action.getCreatesuborchestration()?.getName());
                        }
                    }
                    break;
                case pb.HistoryEvent.EventtypeCase.SUBORCHESTRATIONINSTANCECOMPLETED:
                    {
                        const subOrchestrationInstanceCompletedEvent = event.getSuborchestrationinstancecompleted();
                        const taskId = subOrchestrationInstanceCompletedEvent
                            ? subOrchestrationInstanceCompletedEvent.getTaskscheduledid()
                            : undefined;
                        let subOrchTask;
                        if (taskId) {
                            subOrchTask = ctx._pendingTasks[taskId];
                            delete ctx._pendingTasks[taskId];
                        }
                        let result;
                        if (!(0, pb_helper_util_1.isEmpty)(event.getSuborchestrationinstancecompleted()?.getResult())) {
                            result = JSON.parse(event.getSuborchestrationinstancecompleted()?.getResult()?.toString() || "");
                        }
                        if (subOrchTask) {
                            subOrchTask.complete(result);
                        }
                        await ctx.resume();
                    }
                    break;
                case pb.HistoryEvent.EventtypeCase.SUBORCHESTRATIONINSTANCEFAILED:
                    {
                        const subOrchestrationInstanceFailedEvent = event.getSuborchestrationinstancefailed();
                        const taskId = subOrchestrationInstanceFailedEvent
                            ? subOrchestrationInstanceFailedEvent.getTaskscheduledid()
                            : undefined;
                        let subOrchTask;
                        if (taskId) {
                            subOrchTask = ctx._pendingTasks[taskId];
                            delete ctx._pendingTasks[taskId];
                        }
                        if (!subOrchTask) {
                            // TODO: Should this be an error? When would it ever happen?
                            if (!ctx._isReplaying) {
                                console.warn(`${ctx._instanceId}: Ignoring unexpected subOrchestrationInstanceFailed event with ID = ${taskId}`);
                            }
                            return;
                        }
                        subOrchTask.fail(`${ctx._instanceId}: Sub-orchestration task #${taskId} failed: ${event
                            .getSuborchestrationinstancefailed()
                            ?.getFailuredetails()
                            ?.getErrormessage()}`, event.getSuborchestrationinstancefailed()?.getFailuredetails());
                        await ctx.resume();
                    }
                    break;
                case pb.HistoryEvent.EventtypeCase.EVENTRAISED:
                    {
                        // Event names are case-insensitive
                        const eventName = event.getEventraised()?.getName()?.toLowerCase();
                        if (!ctx._isReplaying) {
                            console.log(`${ctx._instanceId}: Event raised: ${eventName}`);
                        }
                        let taskList;
                        if (eventName) {
                            taskList = ctx._pendingEvents[eventName];
                        }
                        let decodedResult;
                        if (taskList) {
                            const eventTask = taskList.shift();
                            if (!(0, pb_helper_util_1.isEmpty)(event.getEventraised()?.getInput())) {
                                decodedResult = JSON.parse(event.getEventraised()?.getInput()?.toString() || "");
                            }
                            if (eventTask) {
                                eventTask.complete(decodedResult);
                            }
                            if (!taskList && eventName) {
                                delete ctx._pendingEvents[eventName];
                            }
                            await ctx.resume();
                        }
                        else {
                            // Buffer the event
                            let eventList = [];
                            if (eventName) {
                                eventList = ctx._receivedEvents[eventName];
                                if (!eventList?.length) {
                                    eventList = [];
                                    ctx._receivedEvents[eventName] = eventList;
                                }
                            }
                            if (!(0, pb_helper_util_1.isEmpty)(event.getEventraised()?.getInput())) {
                                decodedResult = JSON.parse(event.getEventraised()?.getInput()?.toString() || "");
                            }
                            eventList?.push(decodedResult);
                            if (!ctx._isReplaying) {
                                console.log(`${ctx._instanceId}: Event ${eventName} has been buffered as there are no tasks waiting for it.`);
                            }
                        }
                    }
                    break;
                case pb.HistoryEvent.EventtypeCase.EXECUTIONSUSPENDED:
                    {
                        if (!this._isSuspended && !ctx._isReplaying) {
                            console.log(`${ctx._instanceId}: Execution suspended`);
                        }
                        this._isSuspended = true;
                    }
                    break;
                case pb.HistoryEvent.EventtypeCase.EXECUTIONRESUMED:
                    if (!this._isSuspended) {
                        return;
                    }
                    this._isSuspended = false;
                    for (const e of this._suspendedEvents) {
                        await this.processEvent(ctx, e);
                    }
                    this._suspendedEvents = [];
                    break;
                case pb.HistoryEvent.EventtypeCase.EXECUTIONTERMINATED: {
                    if (!ctx._isReplaying) {
                        console.log(`${ctx._instanceId}: Execution terminated`);
                    }
                    let encodedOutput;
                    if (!(0, pb_helper_util_1.isEmpty)(event.getExecutionterminated()?.getInput())) {
                        encodedOutput = event.getExecutionterminated()?.getInput()?.getValue();
                    }
                    ctx.setComplete(encodedOutput, pb.OrchestrationStatus.ORCHESTRATION_STATUS_TERMINATED, true);
                    break;
                }
                default:
                    console.info(`Unknown history event type: ${eventTypeName} (value: ${eventType}), skipping...`);
                // throw new OrchestrationStateError(`Unknown history event type: ${eventTypeName} (value: ${eventType})`);
            }
        }
        catch (e) {
            // StopIteration is thrown when the generator is finished and didn't return a task as its next action
            if (e instanceof stop_iteration_error_1.StopIterationError) {
                ctx.setComplete(e.value, pb.OrchestrationStatus.ORCHESTRATION_STATUS_COMPLETED);
                return;
            }
            // For the rest we don't do anything
            // Else we throw it upwards
            console.error(`Could not process the event ${eventTypeName} due to error ${e}`);
            throw e;
        }
    }
}
exports.OrchestrationExecutor = OrchestrationExecutor;
