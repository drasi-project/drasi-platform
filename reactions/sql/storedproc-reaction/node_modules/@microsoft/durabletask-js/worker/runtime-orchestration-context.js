"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeOrchestrationContext = void 0;
const task_1 = require("../task");
const orchestration_context_1 = require("../task/context/orchestration-context");
const pb = __importStar(require("../proto/orchestrator_service_pb"));
const ph = __importStar(require("../utils/pb-helper.util"));
const completable_task_1 = require("../task/completable-task");
const task_2 = require("../task/task");
const stop_iteration_error_1 = require("./exception/stop-iteration-error");
class RuntimeOrchestrationContext extends orchestration_context_1.OrchestrationContext {
    constructor(instanceId) {
        super();
        this._generator = undefined;
        this._isReplaying = true;
        this._isComplete = false;
        this._result = undefined;
        this._pendingActions = {};
        this._pendingTasks = {};
        this._sequenceNumber = 0;
        this._currentUtcDatetime = new Date(1000, 0, 1);
        this._instanceId = instanceId;
        this._completionStatus = undefined;
        this._receivedEvents = {};
        this._pendingEvents = {};
        this._newInput = undefined;
        this._saveEvents = false;
    }
    get instanceId() {
        return this._instanceId;
    }
    get currentUtcDateTime() {
        return this._currentUtcDatetime;
    }
    get isReplaying() {
        return this._isReplaying;
    }
    /**
     * This is the main entry point for the orchestrator. It will run the generator
     * and return the first task to be executed. It is typically executed from the
     * orchestrator executor.
     *
     * @param generator
     */
    async run(generator) {
        this._generator = generator;
        // TODO: do something with this task
        // start the generator
        const { value, done } = await this._generator.next();
        // if the generator finished, complete the orchestration.
        if (done) {
            this.setComplete(value, pb.OrchestrationStatus.ORCHESTRATION_STATUS_COMPLETED);
            return;
        }
        // TODO: check if the task is null?
        this._previousTask = value;
    }
    async resume() {
        // This is never expected unless maybe there's an issue with the history
        if (!this._generator) {
            throw new Error("The orchestrator generator is not initialized! Was the orchestration history corrupted?");
        }
        // We can resume the generator only if the previously yielded task
        // has reached a completed state. The only time this won't be the
        // case is if the user yielded on a WhenAll task and there are still
        // outstanding child tasks that need to be completed.
        if (this._previousTask) {
            if (this._previousTask.isFailed) {
                // Raise the failure as an exception to the generator. The orchestrator can then either
                // handle the exception or allow it to fail the orchestration.
                await this._generator.throw(this._previousTask._exception);
            }
            else if (this._previousTask.isComplete) {
                while (true) {
                    // Resume the generator. This will either return a Task or raise StopIteration if it's done.
                    // @todo: Should we check for possible infinite loops here?
                    // python: next_task = self._generator.send(self._previous_task.get_result())
                    // This returns a Promise that we will not await yet
                    // the generator will return an IteratorResult with its next value
                    // note that we are working with an AsyncGenerator, so we should await
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next
                    const { done, value } = await this._generator.next(this._previousTask._result);
                    // If we are done, raise StopIteration
                    if (done) {
                        throw new stop_iteration_error_1.StopIterationError(value);
                    }
                    if (!(value instanceof task_2.Task)) {
                        throw new Error("The orchestrator generator yielded a non-Task object");
                    }
                    this._previousTask = value;
                    // If a completed task was returned, then we can keep running the generator function.
                    // TODO: What about the done from the generator?
                    if (!this._previousTask.isComplete) {
                        break;
                    }
                }
            }
        }
    }
    setComplete(result, status, isResultEncoded = false) {
        if (this._isComplete) {
            return;
        }
        this._isComplete = true;
        this._completionStatus = status;
        this._pendingActions = {}; // Clear any pending actions
        this._result = result;
        let resultJson;
        if (result) {
            resultJson = isResultEncoded ? result : JSON.stringify(result);
        }
        const action = ph.newCompleteOrchestrationAction(this.nextSequenceNumber(), status, resultJson);
        this._pendingActions[action.getId()] = action;
    }
    setFailed(e) {
        // should allow orchestration to fail, even it's completed.
        // if (this._isComplete) {
        //   return;
        // }
        this._isComplete = true;
        this._completionStatus = pb.OrchestrationStatus.ORCHESTRATION_STATUS_FAILED;
        this._pendingActions = {}; // Cancel any pending actions
        const action = ph.newCompleteOrchestrationAction(this.nextSequenceNumber(), pb.OrchestrationStatus.ORCHESTRATION_STATUS_FAILED, undefined, ph.newFailureDetails(e));
        this._pendingActions[action.getId()] = action;
    }
    setContinuedAsNew(newInput, saveEvents) {
        if (this._isComplete) {
            return;
        }
        this._isComplete = true;
        this._pendingActions = {}; // Clear any pending actions
        this._completionStatus = pb.OrchestrationStatus.ORCHESTRATION_STATUS_CONTINUED_AS_NEW;
        this._newInput = newInput;
        this._saveEvents = saveEvents;
    }
    getActions() {
        if (this._completionStatus === pb.OrchestrationStatus.ORCHESTRATION_STATUS_CONTINUED_AS_NEW) {
            // Only return the single completion actions when continuing-as-new
            let carryoverEvents = null;
            if (this._saveEvents) {
                carryoverEvents = [];
                // We need to save the current sent of pending events so that they can be
                // replayed when the new instance starts
                for (const [eventName, values] of Object.entries(this._receivedEvents)) {
                    for (const eventValue of values) {
                        const encodedValue = eventValue ? JSON.stringify(eventValue) : undefined;
                        carryoverEvents.push(ph.newEventRaisedEvent(eventName, encodedValue));
                    }
                }
            }
            const action = ph.newCompleteOrchestrationAction(this.nextSequenceNumber(), pb.OrchestrationStatus.ORCHESTRATION_STATUS_CONTINUED_AS_NEW, this._newInput ? JSON.stringify(this._newInput) : undefined, undefined, carryoverEvents);
            return [action];
        }
        return Object.values(this._pendingActions);
    }
    nextSequenceNumber() {
        return ++this._sequenceNumber;
    }
    /**
     * Create a timer
     *
     * @param fireAt number Amount of seconds between now and when the timer should fire
     * @param fireAt Date The date when the timer should fire
     * @returns
     */
    createTimer(fireAt) {
        const id = this.nextSequenceNumber();
        // If a number is passed, we use it as the number of seconds to wait
        // we use instanceof Date as number is not a native Javascript type
        if (!(fireAt instanceof Date)) {
            fireAt = new Date(Date.now() + fireAt * 1000);
        }
        const action = ph.newCreateTimerAction(id, fireAt);
        this._pendingActions[action.getId()] = action;
        const timerTask = new completable_task_1.CompletableTask();
        this._pendingTasks[id] = timerTask;
        return timerTask;
    }
    callActivity(activity, input) {
        const id = this.nextSequenceNumber();
        const name = typeof activity === "string" ? activity : (0, task_1.getName)(activity);
        const encodedInput = input ? JSON.stringify(input) : undefined;
        const action = ph.newScheduleTaskAction(id, name, encodedInput);
        this._pendingActions[action.getId()] = action;
        const task = new completable_task_1.CompletableTask();
        this._pendingTasks[id] = task;
        return task;
    }
    callSubOrchestrator(orchestrator, input, instanceId) {
        let name;
        if (typeof orchestrator === "string") {
            name = orchestrator;
        }
        else {
            name = (0, task_1.getName)(orchestrator);
        }
        const id = this.nextSequenceNumber();
        // Create a deterministic instance ID based on the parent instance ID
        // use the instanceId and apprent the id to it in hexadecimal with 4 digits (e.g. 0001)
        if (!instanceId) {
            const instanceIdSuffix = id.toString(16).padStart(4, "0");
            instanceId = `${this._instanceId}:${instanceIdSuffix}`;
        }
        const encodedInput = input ? JSON.stringify(input) : undefined;
        const action = ph.newCreateSubOrchestrationAction(id, name, instanceId, encodedInput);
        this._pendingActions[action.getId()] = action;
        const task = new completable_task_1.CompletableTask();
        this._pendingTasks[id] = task;
        return task;
    }
    waitForExternalEvent(name) {
        // Check to see if this event has already been received, in which case we
        // can return it immediately. Otherwise, record out intent to receive an
        // event with the given name so that we can resume the generator when it
        // arrives. If there are multiple events with the same name, we return
        // them in the order they were received.
        const externalEventTask = new completable_task_1.CompletableTask();
        const eventName = name.toLocaleLowerCase();
        const eventList = this._receivedEvents[eventName];
        if (eventList?.length) {
            const eventData = eventList.shift();
            if (!eventList?.length) {
                delete this._receivedEvents[eventName];
            }
            externalEventTask.complete(eventData);
        }
        else {
            let taskList = this._pendingEvents[eventName];
            if (!taskList?.length) {
                taskList = [];
                this._pendingEvents[eventName] = taskList;
            }
            taskList.push(externalEventTask);
        }
        return externalEventTask;
    }
    /**
     * Orchestrations can be continued as new. This API allows an  orchestration to restart itself from scratch, optionally with a new input.
     */
    continueAsNew(newInput, saveEvents = false) {
        if (this._isComplete) {
            return;
        }
        this.setContinuedAsNew(newInput, saveEvents);
    }
}
exports.RuntimeOrchestrationContext = RuntimeOrchestrationContext;
