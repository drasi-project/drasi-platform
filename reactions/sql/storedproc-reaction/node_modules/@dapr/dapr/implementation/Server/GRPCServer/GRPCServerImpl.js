"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const any_pb_1 = require("google-protobuf/google/protobuf/any_pb");
const common_pb_1 = require("../../../proto/dapr/proto/common/v1/common_pb");
const appcallback_pb_1 = require("../../../proto/dapr/proto/runtime/v1/appcallback_pb");
const HttpVerbUtil = __importStar(require("../../../utils/HttpVerb.util"));
const Logger_1 = require("../../../logger/Logger");
const DaprPubSubStatus_enum_1 = __importDefault(require("../../../enum/DaprPubSubStatus.enum"));
const Deserializer_util_1 = require("../../../utils/Deserializer.util");
const Settings_util_1 = require("../../../utils/Settings.util");
const subscriptionManager_1 = require("../../../pubsub/subscriptionManager");
// https://github.com/badsyntax/grpc-js-typescript/issues/1#issuecomment-705419742
// @ts-ignore
class GRPCServerImpl {
    constructor(_server, loggerOptions) {
        this.logger = new Logger_1.Logger("GRPCServer", "GRPCServerImpl", loggerOptions);
        this.subscriptionManager = new subscriptionManager_1.SubscriptionManager();
        this.handlersInvoke = {};
        this.handlersBindings = {};
    }
    createInputBindingHandlerKey(bindingName) {
        return `${bindingName.toLowerCase()}`;
    }
    createOnInvokeHandlerKey(httpMethod, methodName) {
        return `${httpMethod.toLowerCase()}|${methodName.toLowerCase()}`;
    }
    registerOnInvokeHandler(httpMethod, methodName, cb) {
        const handlerKey = this.createOnInvokeHandlerKey(httpMethod, methodName);
        this.handlersInvoke[handlerKey] = cb;
    }
    /**
     * When we subscribe, we subscribe to a topic
     * For this topic we can define "routes" which route to a certain callback depending on the event content
     * Each of these topics are handled by a EventHandler but there can be multiple handlers per pubsubname-topic-route combination
     *
     * We don't create the EventHandlers here but we ensure that the routes are registered and can receive POST events
     * -> we create POST /<route> endpoints for each, but we create them uniquely!
     * -> to ensure uniqueness, we just check if this.pubsubRouteEventHandlers[route] is set
     *
     * @param pubSubName
     * @param topicName
     * @param cb
     * @param options
     */
    registerPubsubSubscription(pubsubName, topic, options = {}) {
        this.subscriptionManager.registerSubscription(pubsubName, topic, options);
        this.logger.info(`[Topic = ${topic}] Registered Subscription with routes: ${Object.keys(this.subscriptionManager.getSubscription(pubsubName, topic).routes).join(", ")}`);
    }
    registerPubSubSubscriptionEventHandler(pubsubName, topic, route, cb) {
        this.subscriptionManager.addEventHandlerToSubscription(pubsubName, topic, cb, route);
    }
    registerInputBindingHandler(bindingName, cb) {
        const handlerKey = this.createInputBindingHandlerKey(bindingName);
        this.handlersBindings[handlerKey] = cb;
    }
    getSubscriptions() {
        return this.subscriptionManager.getSubscriptions();
    }
    // '(call: ServerUnaryCall<InvokeRequest, InvokeResponse>, callback: sendUnaryData<InvokeResponse>) => Promise<...>'
    // handleUnaryCall<InvokeRequest, InvokeResponse>'.
    async onInvoke(call, callback) {
        const method = call.request.getMethod();
        const query = call.request.getHttpExtension().toObject();
        const methodStr = HttpVerbUtil.convertHttpVerbNumberToString(query.verb);
        const handlersInvokeKey = `${methodStr.toLowerCase()}|${method.toLowerCase()}`;
        if (!this.handlersInvoke[handlersInvokeKey]) {
            this.logger.warn(`${methodStr} /${method} was not handled`);
            return;
        }
        const body = Buffer.from(call.request.getData().getValue()).toString();
        const contentType = call.request.getContentType();
        // Invoke the Method Callback
        // @TODO add call.metadata, it has headers of original HTTP request.
        const invokeResponseData = await this.handlersInvoke[handlersInvokeKey]({
            body,
            query: query.querystring,
            metadata: {
                contentType,
            },
        });
        // Generate Response
        const res = new common_pb_1.InvokeResponse();
        res.setContentType("application/json");
        if (invokeResponseData) {
            const msgSerialized = new any_pb_1.Any();
            msgSerialized.setValue(Buffer.from(JSON.stringify(invokeResponseData), "utf-8"));
            res.setData(msgSerialized);
        }
        // @TODO add Error Handleling, for ex if service returned error with status code
        // also maybe we can map GRPC error codes in a enum
        return callback(null, res);
    }
    // @todo: WIP
    async onBindingEvent(call, callback) {
        const req = call.request;
        const handlerKey = this.createInputBindingHandlerKey(req.getName());
        if (!this.handlersBindings[handlerKey]) {
            this.logger.warn(`Event for binding: "${handlerKey}" was not handled`);
            return;
        }
        const data = Buffer.from(req.getData()).toString();
        let dataParsed;
        try {
            dataParsed = JSON.parse(data);
        }
        catch (e) {
            dataParsed = data;
        }
        await this.handlersBindings[handlerKey](dataParsed);
        // @todo: we should add the state store or output binding binding
        // see: https://docs.dapr.io/reference/api/bindings_api/#binding-endpoints
        const res = new appcallback_pb_1.BindingEventResponse();
        return callback(null, res);
    }
    async onTopicEvent(call, callback) {
        const req = call.request;
        const pubsub = req.getPubsubName();
        if (!this.subscriptionManager.isPubSubRegistered(pubsub)) {
            this.logger.warn(`PubSub '${pubsub}' has not been registered, ignoring event.`);
            return;
        }
        const [topic, route] = this.subscriptionManager.lookupTopicWilcard(pubsub, req.getTopic(), req.getPath());
        if (topic == "") {
            this.logger.warn(`Topic '${topic}' has not been subscribed to pubsub '${pubsub}', ignoring event.`);
            return;
        }
        const subscription = this.subscriptionManager.getSubscription(pubsub, topic);
        if (!subscription.routes[route]) {
            this.logger.warn(`Route '${route}' has not been subscribed to topic '${topic}' on pubsub '${pubsub}', ignoring event.`);
            return;
        }
        const data = (0, Deserializer_util_1.deserializeGrpc)(req.getDataContentType(), req.getData());
        const res = new appcallback_pb_1.TopicEventResponse();
        // Get the headers
        const headers = {};
        for (const [key, value] of Object.entries(call.metadata.toHttp2Headers())) {
            if (value) {
                headers[key] = value.toString();
            }
        }
        // Process the callbacks
        // we handle priority of status on `RETRY` > `DROP` > `SUCCESS` and default to `SUCCESS`
        const routeObj = subscription.routes[route];
        const status = await this.processPubSubCallbacks(routeObj, data, headers);
        switch (status) {
            case DaprPubSubStatus_enum_1.default.RETRY:
                res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.RETRY);
                break;
            case DaprPubSubStatus_enum_1.default.DROP:
                res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.DROP);
                break;
            case DaprPubSubStatus_enum_1.default.SUCCESS:
            default:
                res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.SUCCESS);
                break;
        }
        return callback(null, res);
    }
    async onBulkTopicEventAlpha1(call, callback) {
        const req = call.request;
        const pubsub = req.getPubsubName();
        if (!this.subscriptionManager.isPubSubRegistered(pubsub)) {
            this.logger.warn(`PubSub '${pubsub}' has not been registered, ignoring bulk event.`);
            return;
        }
        const [topic, route] = this.subscriptionManager.lookupTopicWilcard(pubsub, req.getTopic(), req.getPath());
        if (topic == "") {
            this.logger.warn(`Topic '${topic}' has not been subscribed to pubsub '${pubsub}', ignoring bulk event.`);
            return;
        }
        const subscription = this.subscriptionManager.getSubscription(pubsub, topic);
        if (!subscription.routes[route]) {
            this.logger.warn(`Route '${route}' has not been subscribed to topic '${topic}' on pubsub '${pubsub}', ignoring bulk event.`);
            return;
        }
        const resArr = [];
        const entries = req.getEntriesList();
        for (const ind in entries) {
            const event = entries[ind];
            let data;
            if (event.hasBytes()) {
                data = (0, Deserializer_util_1.deserializeGrpc)(event.getContentType(), event.getBytes());
            }
            else if (event.hasCloudEvent()) {
                const cloudEvent = event.getCloudEvent();
                if (cloudEvent instanceof appcallback_pb_1.TopicEventCERequest) {
                    data = (0, Deserializer_util_1.deserializeGrpc)(cloudEvent.getDataContentType(), cloudEvent.getData());
                }
            }
            const res = new appcallback_pb_1.TopicEventBulkResponseEntry();
            // Get the headers
            const headers = {};
            for (const [key, value] of Object.entries(call.metadata.toHttp2Headers())) {
                if (value) {
                    headers[key] = value.toString();
                }
            }
            // Process the callbacks
            // we handle priority of status on `RETRY` > `DROP` > `SUCCESS` and default to `SUCCESS`
            const routeObj = subscription.routes[route];
            const status = await this.processPubSubCallbacks(routeObj, data, headers);
            switch (status) {
                case DaprPubSubStatus_enum_1.default.RETRY:
                    res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.RETRY);
                    break;
                case DaprPubSubStatus_enum_1.default.DROP:
                    res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.DROP);
                    break;
                case DaprPubSubStatus_enum_1.default.SUCCESS:
                default:
                    res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.SUCCESS);
                    break;
            }
            res.setEntryId(event.getEntryId());
            resArr.push(res);
        }
        const totalRes = new appcallback_pb_1.TopicEventBulkResponse();
        totalRes.setStatusesList(resArr);
        return callback(null, totalRes);
    }
    async processPubSubCallbacks(routeObj, data, headers) {
        const eventHandlers = routeObj.eventHandlers;
        const statuses = [];
        // Process the callbacks (default: SUCCESS)
        for (const cb of eventHandlers) {
            let status = DaprPubSubStatus_enum_1.default.SUCCESS;
            try {
                status = await cb(data, headers);
            }
            catch (e) {
                // We catch and log an error, but we don't do anything with it as the statuses should define that
                this.logger.error(`[route - ${routeObj.path}]Message processing failed, ${e}`);
            }
            statuses.push(status ?? DaprPubSubStatus_enum_1.default.SUCCESS);
        }
        // Look at the statuses and return the highest priority
        // we handle priority of status on `RETRY` > `DROP` > `SUCCESS`
        if (statuses.includes(DaprPubSubStatus_enum_1.default.RETRY)) {
            this.logger.debug(`[route - ${routeObj.path}]Retrying message`);
            return DaprPubSubStatus_enum_1.default.RETRY;
        }
        else if (statuses.includes(DaprPubSubStatus_enum_1.default.DROP)) {
            this.logger.debug(`[route - ${routeObj.path}]Dropping message`);
            return DaprPubSubStatus_enum_1.default.DROP;
        }
        else {
            this.logger.debug(`[route - ${routeObj.path}]Acknowledging message`);
            return DaprPubSubStatus_enum_1.default.SUCCESS;
        }
    }
    // Dapr will call this on startup to see which topics it is subscribed to
    async listTopicSubscriptions(call, callback) {
        const res = new appcallback_pb_1.ListTopicSubscriptionsResponse();
        const subscriptions = [];
        for (const pubsub of this.subscriptionManager.getRegisteredPubSubs()) {
            for (const topic of this.subscriptionManager.getRegisteredTopics(pubsub)) {
                const topicSubscription = new appcallback_pb_1.TopicSubscription();
                topicSubscription.setPubsubName(pubsub);
                topicSubscription.setTopic(topic);
                // Dapr routes
                const daprConfig = this.subscriptionManager.getSubscription(pubsub, topic).dapr;
                if (daprConfig?.deadLetterTopic) {
                    topicSubscription.setDeadLetterTopic(daprConfig.deadLetterTopic);
                }
                if (daprConfig?.bulkSubscribe) {
                    const bulkSubscribe = new appcallback_pb_1.BulkSubscribeConfig();
                    bulkSubscribe.setEnabled(daprConfig.bulkSubscribe.enabled);
                    if (daprConfig?.bulkSubscribe?.maxMessagesCount) {
                        bulkSubscribe.setMaxMessagesCount(daprConfig.bulkSubscribe.maxMessagesCount);
                    }
                    if (daprConfig?.bulkSubscribe?.maxAwaitDurationMs) {
                        bulkSubscribe.setMaxAwaitDurationMs(daprConfig.bulkSubscribe.maxAwaitDurationMs);
                    }
                    topicSubscription.setBulkSubscribe(bulkSubscribe);
                }
                if (daprConfig?.metadata) {
                    for (const [mKey, mValue] of Object.entries(daprConfig.metadata)) {
                        topicSubscription.getMetadataMap().set(mKey, mValue);
                    }
                }
                if (daprConfig?.routes) {
                    const routes = new appcallback_pb_1.TopicRoutes();
                    if (daprConfig?.routes?.default) {
                        routes.setDefault(daprConfig?.routes?.default);
                    }
                    if (daprConfig?.routes?.rules) {
                        for (const ruleItem of daprConfig.routes.rules) {
                            const rule = new appcallback_pb_1.TopicRule();
                            rule.setMatch(ruleItem.match);
                            rule.setPath(ruleItem.path);
                            routes.addRules(rule);
                        }
                    }
                    topicSubscription.setRoutes(routes);
                }
                else {
                    const routes = new appcallback_pb_1.TopicRoutes();
                    routes.setDefault(daprConfig?.route || Settings_util_1.Settings.getDefaultPubSubRouteName());
                    topicSubscription.setRoutes(routes);
                }
                subscriptions.push(topicSubscription);
            }
        }
        res.setSubscriptionsList(subscriptions);
        return callback(null, res);
    }
    // @todo: WIP
    async listInputBindings(call, callback) {
        const res = new appcallback_pb_1.ListInputBindingsResponse();
        res.setBindingsList(Object.keys(this.handlersBindings));
        return callback(null, res);
    }
}
exports.default = GRPCServerImpl;
