"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GRPCClient_1 = __importDefault(require("./GRPCClient/GRPCClient"));
const actor_1 = __importDefault(require("./GRPCClient/actor"));
const binding_1 = __importDefault(require("./GRPCClient/binding"));
const configuration_1 = __importDefault(require("./GRPCClient/configuration"));
const crypto_1 = __importDefault(require("./GRPCClient/crypto"));
const health_1 = __importDefault(require("./GRPCClient/health"));
const invoker_1 = __importDefault(require("./GRPCClient/invoker"));
const lock_1 = __importDefault(require("./GRPCClient/lock"));
const metadata_1 = __importDefault(require("./GRPCClient/metadata"));
const pubsub_1 = __importDefault(require("./GRPCClient/pubsub"));
const secret_1 = __importDefault(require("./GRPCClient/secret"));
const sidecar_1 = __importDefault(require("./GRPCClient/sidecar"));
const state_1 = __importDefault(require("./GRPCClient/state"));
const workflow_1 = __importDefault(require("./GRPCClient/workflow"));
const HTTPClient_1 = __importDefault(require("./HTTPClient/HTTPClient"));
const actor_2 = __importDefault(require("./HTTPClient/actor"));
const binding_2 = __importDefault(require("./HTTPClient/binding"));
const configuration_2 = __importDefault(require("./HTTPClient/configuration"));
const crypto_2 = __importDefault(require("./HTTPClient/crypto"));
const health_2 = __importDefault(require("./HTTPClient/health"));
const invoker_2 = __importDefault(require("./HTTPClient/invoker"));
const lock_2 = __importDefault(require("./HTTPClient/lock"));
const metadata_2 = __importDefault(require("./HTTPClient/metadata"));
const proxy_1 = __importDefault(require("./HTTPClient/proxy"));
const pubsub_2 = __importDefault(require("./HTTPClient/pubsub"));
const secret_2 = __importDefault(require("./HTTPClient/secret"));
const sidecar_2 = __importDefault(require("./HTTPClient/sidecar"));
const state_2 = __importDefault(require("./HTTPClient/state"));
const workflow_2 = __importDefault(require("./HTTPClient/workflow"));
const CommunicationProtocol_enum_1 = __importDefault(require("../../enum/CommunicationProtocol.enum"));
const Settings_util_1 = require("../../utils/Settings.util");
const Logger_1 = require("../../logger/Logger");
const proxy_2 = __importDefault(require("./GRPCClient/proxy"));
const NodeJSUtils = __importStar(require("../../utils/NodeJS.util"));
const Client_util_1 = require("../../utils/Client.util");
class DaprClient {
    constructor(options = {}) {
        options = (0, Client_util_1.getClientOptions)(options, Settings_util_1.Settings.getDefaultCommunicationProtocol(), undefined);
        this.logger = new Logger_1.Logger("DaprClient", "DaprClient", options.logger);
        // Legacy validation on port
        // URI validation is done later, when we instantiate the HttpEndpoint or GrpcEndpoint
        // object in the HttpClient or GrpcClient constructor, but we need to
        // keep this additional check for backward compatibility
        // TODO: Remove this validation in the next major version
        if (options?.daprPort && !/^[0-9]+$/.test(options?.daprPort)) {
            throw new Error("DAPR_INCORRECT_SIDECAR_PORT");
        }
        // Builder
        switch (options.communicationProtocol) {
            case CommunicationProtocol_enum_1.default.GRPC: {
                const client = new GRPCClient_1.default(options);
                this.daprClient = client;
                this.state = new state_1.default(client);
                this.pubsub = new pubsub_1.default(client);
                this.binding = new binding_1.default(client);
                this.invoker = new invoker_1.default(client);
                this.secret = new secret_1.default(client);
                this.health = new health_1.default(client);
                this.metadata = new metadata_1.default(client);
                this.sidecar = new sidecar_1.default(client);
                this.proxy = new proxy_2.default(client);
                this.configuration = new configuration_1.default(client);
                this.lock = new lock_1.default(client);
                this.crypto = new crypto_1.default(client);
                this.actor = new actor_1.default(client); // we use an abstractor here since we interface through a builder with the Actor Runtime
                this.workflow = new workflow_1.default(client);
                break;
            }
            case CommunicationProtocol_enum_1.default.HTTP:
            default: {
                const client = new HTTPClient_1.default(options);
                this.daprClient = client;
                this.actor = new actor_2.default(client); // we use an abstractor here since we interface through a builder with the Actor Runtime
                this.binding = new binding_2.default(client);
                this.configuration = new configuration_2.default(client);
                this.crypto = new crypto_2.default(client);
                this.health = new health_2.default(client);
                this.invoker = new invoker_2.default(client);
                this.lock = new lock_2.default(client);
                this.metadata = new metadata_2.default(client);
                this.proxy = new proxy_1.default(client);
                this.pubsub = new pubsub_2.default(client);
                this.secret = new secret_2.default(client);
                this.sidecar = new sidecar_2.default(client);
                this.state = new state_2.default(client);
                this.workflow = new workflow_2.default(client);
                break;
            }
        }
        this.options = {
            daprHost: this.daprClient.options.daprHost,
            daprPort: this.daprClient.options.daprPort,
            communicationProtocol: this.daprClient.options.communicationProtocol,
            isKeepAlive: options.isKeepAlive,
            logger: options.logger,
            actor: options.actor,
            daprApiToken: options.daprApiToken,
            maxBodySizeMb: options.maxBodySizeMb,
        };
    }
    static create(client) {
        return new DaprClient(client.options);
    }
    static async awaitSidecarStarted(fnIsSidecarStarted, logger) {
        // Dapr will probe every 50ms to see if we are listening on our port: https://github.com/dapr/dapr/blob/a43712c97ead550ca2f733e9f7e7769ecb195d8b/pkg/runtime/runtime.go#L1694
        // if we are using actors we will change this to 4s to let the placement tables update
        let isStarted = await fnIsSidecarStarted();
        let isStartedRetryCount = 0;
        const isStartedMaxRetryCount = 60; // 1s startup delay and we try max for 60s
        if (isStarted) {
            return;
        }
        logger.info(`Awaiting Sidecar to be Started`);
        while (!isStarted) {
            logger.verbose(`Waiting for the Dapr Sidecar to start, retry count: (#${isStartedRetryCount})`);
            await NodeJSUtils.sleep(Settings_util_1.Settings.getDaprSidecarPollingDelayMs());
            // Implement API call manually as we need to enable calling without initialization
            // everything routes through the `execute` method
            // to check health, we just ping the /metadata endpoint and see if we get a response
            isStarted = await fnIsSidecarStarted();
            // Finally, Handle the retry logic
            isStartedRetryCount++;
            if (isStartedRetryCount > isStartedMaxRetryCount) {
                throw new Error("DAPR_SIDECAR_COULD_NOT_BE_STARTED");
            }
        }
    }
    async stop() {
        await this.daprClient.stop();
    }
    async start() {
        await this.daprClient.start();
    }
    getIsInitialized() {
        return this.daprClient.getIsInitialized();
    }
}
exports.default = DaprClient;
