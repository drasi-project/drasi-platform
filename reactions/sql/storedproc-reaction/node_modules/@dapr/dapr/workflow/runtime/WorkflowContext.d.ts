import { OrchestrationContext } from "@microsoft/durabletask-js";
import { Task } from "@microsoft/durabletask-js/task/task";
import { TWorkflowActivity } from "../../types/workflow/Activity.type";
import { TWorkflow } from "../../types/workflow/Workflow.type";
import { WhenAllTask } from "@microsoft/durabletask-js/task/when-all-task";
import { WhenAnyTask } from "@microsoft/durabletask-js/task/when-any-task";
import { TInput, TOutput } from "../../types/workflow/InputOutput.type";
/**
 * Used by workflow to perform actions such as scheduling tasks, durable timers, waiting for external events,
 * and for getting basic information about the current workflow.
 */
export default class WorkflowContext {
    private readonly _innerContext;
    constructor(innerContext: OrchestrationContext);
    /**
     * Gets the unique ID of the current orchestration instance.
     * @returns {string} The unique ID of the current orchestration instance
     */
    getWorkflowInstanceId(): string;
    /**
     * Get the current date/time as UTC
     *
     * @returns {Date} The current timestamp in a way that is safe for use by orchestrator functions
     */
    getCurrentUtcDateTime(): Date;
    /**
     * Get the value indicating whether the orchestrator is replaying from history.
     *
     * This property is useful when there is logic that needs to run only when
     * the orchestrator function is _not_ replaying. For example, certain
     * types of application logging may become too noisy when duplicated as
     * part of orchestrator function replay. The orchestrator code could check
     * to see whether the function is being replayed and then issue the log
     * statements when this value is `false`.
     *
     * @returns {boolean} `true` if the orchestrator function is replaying from history; otherwise, `false`.
     */
    isReplaying(): boolean;
    /**
     * Create a timer task that will fire at a specified time.
     *
     * @param {Date | number} fireAt The time at which the timer should fire.
     * @returns {Task} A Durable Timer task that schedules the timer to wake up the orchestrator
     */
    createTimer(fireAt: Date | number): Task<any>;
    /**
     * Schedules an activity for execution within the orchestrator.
     *
     * @param {TWorkflowActivity<TInput, TOutput> | string} activity - The activity function or its name to call.
     * @param {TInput} [input] - The JSON-serializable input value for the activity function.
     * @returns {Task<TOutput>} - A Durable Task that completes when the activity function completes.
     *
     * @typeparam TWorkflowActivity - The type of the activity function.
     * @typeparam TInput - The type of the input for the activity.
     * @typeparam TOutput - The type of the output for the activity.
     */
    callActivity(activity: TWorkflowActivity<TInput, TOutput> | string, input?: TInput): Task<TOutput>;
    /**
     * Schedule sub-orchestrator function for execution.
     *
     * @param orchestrator A reference to the orchestrator function call
     * @param input The JSON-serializable input value for the orchestrator function.
     * @param instanceId A unique ID to use for the sub-orchestration instance. If not provided, a new GUID will be used.
     *
     * @returns {Task<TOutput>} A Durable Task that completes when the sub-orchestrator function completes.
     */
    callSubWorkflow<TInput, TOutput>(orchestrator: TWorkflow | string, input?: TInput, instanceId?: string): Task<TOutput>;
    /**
     * Wait for an event to be raised with the name "name"
     *
     * @param name The name of the event to wait for
     * @returns {Task} A Durable Task that completes when the event is received
     */
    waitForExternalEvent(name: string): Task<any>;
    /**
     * Continue the orchestration execution as a new instance
     *
     * @param newInput {any} The new input to use for the new orchestration instance.
     * @param saveEvents {boolean} A flag indicating whether to add any unprocessed external events in the new orchestration history.
     */
    continueAsNew(newInput: any, saveEvents: boolean): void;
    /**
     * Returns a task that completes when all of the provided tasks complete or when one of the tasks fail
     *
     * @param tasks the tasks to wait for
     * @returns {WhenAllTask} a task that completes when all of the provided tasks complete or when one of the tasks fail
     */
    whenAll<T>(tasks: Task<T>[]): WhenAllTask<T>;
    /**
     * Returns a task that completes when any of the provided tasks complete or fail
     *
     * @param tasks the tasks to wait for
     * @returns {WhenAnyTask} a task that completes when one of the provided tasks complete or when one of the tasks fail
     */
    whenAny(tasks: Task<any>[]): WhenAnyTask;
}
