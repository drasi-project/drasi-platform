"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ActorStateChange_1 = __importDefault(require("./ActorStateChange"));
const StateChangeKind_1 = __importDefault(require("./StateChangeKind"));
const StateMetadata_1 = __importDefault(require("./StateMetadata"));
class ActorStateManager {
    constructor(actor) {
        this.actor = actor;
        this.defaultStateChangeTracker = new Map();
    }
    getContextualStateTracker() {
        // @todo: reentrancy and context tracking
        // https://github.com/dapr/python-sdk/blob/0f0b6f6a1cf45d2ac0c519b48fc868898d81124e/dapr/actor/runtime/state_manager.py#L236
        return this.defaultStateChangeTracker;
    }
    async addState(stateName, value) {
        const res = await this.tryAddState(stateName, value);
        if (!res) {
            throw new Error(`The actor state name ${stateName} already exist`);
        }
    }
    async tryAddState(stateName, value) {
        const stateChangeTracker = this.getContextualStateTracker();
        if (stateChangeTracker.has(stateName)) {
            const stateMetadata = stateChangeTracker.get(stateName);
            if (stateMetadata?.getChangeKind() === StateChangeKind_1.default.REMOVE) {
                stateChangeTracker.set(stateName, new StateMetadata_1.default(value, StateChangeKind_1.default.UPDATE));
                return true;
            }
            return false;
        }
        const didExist = await this.actor
            .getStateProvider()
            .containsState(this.actor.getActorType(), this.actor.getActorId(), stateName);
        if (!didExist) {
            return false;
        }
        stateChangeTracker.set(stateName, new StateMetadata_1.default(value, StateChangeKind_1.default.ADD));
        return true;
    }
    async getState(stateName) {
        const [hasValue, value] = await this.tryGetState(stateName);
        if (hasValue) {
            return value;
        }
        throw new Error(`Actor state with name ${stateName} was not found`);
    }
    async tryGetState(stateName) {
        const stateChangeTracker = this.getContextualStateTracker();
        if (stateChangeTracker.has(stateName)) {
            const stateMetadata = stateChangeTracker.get(stateName);
            if (stateMetadata?.getChangeKind() === StateChangeKind_1.default.REMOVE) {
                return [false, null];
            }
            const val = stateMetadata?.getValue();
            return [true, val !== undefined ? val : null];
        }
        const [hasValue, value] = await this.actor
            .getStateProvider()
            .tryLoadState(this.actor.getActorType(), this.actor.getActorId(), stateName);
        if (hasValue) {
            stateChangeTracker.set(stateName, new StateMetadata_1.default(value, StateChangeKind_1.default.NONE));
        }
        return [hasValue, value];
    }
    // SEE: https://github.com/dapr/python-sdk/blob/0f0b6f6a1cf45d2ac0c519b48fc868898d81124e/dapr/actor/runtime/state_manager.py#L236
    async setState(stateName, value) {
        const stateChangeTracker = this.getContextualStateTracker();
        if (stateChangeTracker.has(stateName)) {
            const stateMetadata = stateChangeTracker.get(stateName);
            if (!stateMetadata) {
                return;
            }
            stateMetadata.setValue(value);
            if (stateMetadata.getChangeKind() === StateChangeKind_1.default.NONE ||
                stateMetadata.getChangeKind() === StateChangeKind_1.default.REMOVE) {
                stateMetadata.setChangeKind(StateChangeKind_1.default.UPDATE);
            }
            stateChangeTracker.set(stateName, stateMetadata);
            return;
        }
        const didExist = await this.actor
            .getStateProvider()
            .containsState(this.actor.getActorType(), this.actor.getActorId(), stateName);
        if (didExist) {
            stateChangeTracker.set(stateName, new StateMetadata_1.default(value, StateChangeKind_1.default.UPDATE));
        }
        else {
            stateChangeTracker.set(stateName, new StateMetadata_1.default(value, StateChangeKind_1.default.ADD));
        }
    }
    async removeState(stateName) {
        const res = await this.tryRemoveState(stateName);
        if (!res) {
            throw new Error(`The actor state with name ${stateName} was not found`);
        }
    }
    async tryRemoveState(stateName) {
        const stateChangeTracker = this.getContextualStateTracker();
        if (stateChangeTracker.has(stateName)) {
            const stateMetadata = stateChangeTracker.get(stateName);
            if (stateMetadata?.getChangeKind() === StateChangeKind_1.default.REMOVE) {
                return false;
            }
            else if (stateMetadata?.getChangeKind() === StateChangeKind_1.default.ADD) {
                stateChangeTracker.delete(stateName);
                return true;
            }
            stateMetadata?.setChangeKind(StateChangeKind_1.default.REMOVE);
            return true;
        }
        const didExist = await this.actor
            .getStateProvider()
            .containsState(this.actor.getActorType(), this.actor.getActorId(), stateName);
        if (didExist) {
            stateChangeTracker.set(stateName, new StateMetadata_1.default(null, StateChangeKind_1.default.REMOVE));
            return true;
        }
        return false;
    }
    async containsState(stateName) {
        const stateChangeTracker = this.getContextualStateTracker();
        if (stateChangeTracker.has(stateName)) {
            const stateMetadata = stateChangeTracker.get(stateName);
            return stateMetadata?.getChangeKind() !== StateChangeKind_1.default.REMOVE;
        }
        const doesContainState = await this.actor
            .getStateProvider()
            .containsState(this.actor.getActorType(), this.actor.getActorId(), stateName);
        return doesContainState;
    }
    async getOrAddState(stateName, value) {
        const stateChangeTracker = this.getContextualStateTracker();
        const [hasValue, val] = await this.tryGetState(stateName);
        if (hasValue) {
            return val;
        }
        const changeKind = (await this.isStateMarkedForRemove(stateName)) ? StateChangeKind_1.default.UPDATE : StateChangeKind_1.default.ADD;
        stateChangeTracker.set(stateName, new StateMetadata_1.default(value, changeKind));
        return value;
    }
    async isStateMarkedForRemove(stateName) {
        const stateChangeTracker = this.getContextualStateTracker();
        if (stateChangeTracker.has(stateName)) {
            const stateMetadata = stateChangeTracker.get(stateName);
            return stateMetadata?.getChangeKind() === StateChangeKind_1.default.REMOVE;
        }
        return false;
    }
    async addOrUpdateState(stateName, value, updateValueFactory) {
        const stateChangeTracker = this.getContextualStateTracker();
        if (stateChangeTracker.has(stateName)) {
            const stateMetadata = stateChangeTracker.get(stateName);
            if (!stateMetadata) {
                throw new Error("State Metadata was not set");
            }
            if (stateMetadata?.getChangeKind() === StateChangeKind_1.default.REMOVE) {
                stateChangeTracker.set(stateName, new StateMetadata_1.default(value, StateChangeKind_1.default.UPDATE));
                return value;
            }
            const newValue = updateValueFactory(stateName, stateMetadata.getValue());
            stateMetadata.setValue(newValue);
            if (stateMetadata.getChangeKind() === StateChangeKind_1.default.NONE) {
                stateMetadata.setChangeKind(StateChangeKind_1.default.UPDATE);
            }
            stateChangeTracker.set(stateName, stateMetadata);
            return newValue;
        }
        const [hasValue, val] = await this.actor
            .getStateProvider()
            .tryLoadState(this.actor.getActorType(), this.actor.getActorId(), stateName);
        if (hasValue) {
            const newValue = updateValueFactory(stateName, val);
            stateChangeTracker.set(stateName, new StateMetadata_1.default(newValue, StateChangeKind_1.default.UPDATE));
            return newValue;
        }
        stateChangeTracker.set(stateName, new StateMetadata_1.default(value, StateChangeKind_1.default.ADD));
        return value;
    }
    async getStateNames() {
        const stateChangeTracker = this.getContextualStateTracker();
        const stateNames = [];
        stateChangeTracker.forEach((val, key) => {
            if (val.getChangeKind() === StateChangeKind_1.default.ADD || val.getChangeKind() === StateChangeKind_1.default.REMOVE) {
                stateNames.push(key);
            }
        });
        return stateNames;
    }
    async clearCache() {
        const stateChangeTracker = this.getContextualStateTracker();
        stateChangeTracker.clear();
    }
    async saveState() {
        const stateChangeTracker = this.getContextualStateTracker();
        if (stateChangeTracker.size === 0) {
            return;
        }
        const stateChanges = [];
        const statesToRemove = [];
        stateChangeTracker.forEach((stateMetadata, stateName) => {
            if (stateMetadata.getChangeKind() === StateChangeKind_1.default.NONE) {
                return;
            }
            stateChanges.push(new ActorStateChange_1.default(stateName, stateMetadata.getValue(), stateMetadata.getChangeKind()));
            if (stateMetadata.getChangeKind() === StateChangeKind_1.default.REMOVE) {
                statesToRemove.push(stateName);
            }
            // Mark the state as unmodified so that tracking for next invocation is done correctly
            stateMetadata.setChangeKind(StateChangeKind_1.default.NONE);
        });
        if (stateChanges.length > 0) {
            await this.actor.getStateProvider().saveState(this.actor.getActorType(), this.actor.getActorId(), stateChanges);
        }
        for (const stateName of statesToRemove) {
            stateChangeTracker.delete(stateName);
        }
    }
}
exports.default = ActorStateManager;
